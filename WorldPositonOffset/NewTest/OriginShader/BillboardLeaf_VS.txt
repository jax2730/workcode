
#include <Common_Uniform_VS.inl>
#include <Common_Function.inl>

#ifdef USEINSTANCE
    #ifndef SKINNEDINSTANCE
      #undef HWSKINNED
	#endif
#endif

#ifdef USEINSTANCE
    #ifdef SKINNEDINSTANCE
 		uniform Texture2D S_2DExt0;
		SamplerState S_2DExt0SamplerState;
		float4 	U_VSCustom0[InstanceCount*UniformCount];
		uint4   U_VSCustom1[(InstanceCount + 3) >> 2]; // animationData [cpu data type is uint32 , need recalculate index ]
    #else
    	float4 	U_VSCustom0[InstanceCount * UniformCount];
	#endif
#else
	float4	U_WorldMatrix[3];
	float4	U_InvTransposeWorldMatrix[3];
	#ifdef BILLBOARD_LEAF
		float4	U_WorldRotationMatrix[3];
		float4	U_WorldViewProjectNoRotationMatrix[4];
	#else
		float4	U_WorldViewProjectMatrix[4];
	#endif
#endif

#ifdef HWSKINNED
	#ifndef SKINNEDINSTANCE
		float4	U_BoneMatrix[3 * Bone_Matrix_Max_Cnt];
    #endif
#endif

float4	U_WindParamsObjSpace;
float4	U_VSGeneralRegister0;	// x: bend start height
float4	U_VSGeneralRegister1;	// x: sway amplitude, y: sway frequency, z: shake amplitude, w: shake frequency
float4 	U_VSGeneralRegister7; 	//x ---boundingbox min.y (current entity box) local box
								//y ---boundingbox max.y (current entity box)
								//z ---boundingbox min.y (parent entity box)
								//w ---boundingbox max.y (parent entity box)

// generate a triangle wave from a linear wave, range: 0~1
float4 TriangleWave(float4 x)
{
	return abs(frac(x) * 2.0 - 1.0);
}

float4 SmoothCurve(float4 x)
{
	return x * x * (3.0 - 2.0 * x);
}

// smooth a triangle wave, like a sin wave
float4 SmoothTriangleWave(float4 x)
{
	return SmoothCurve(TriangleWave(x));
}

void _TrunkBending(inout float3 vPos, in float fSwayStartHeight,
		in float fTime, in float fPhase, in float4 vWindParams,
		in float fAmp, in float fFreq)
{
	float fBendScale = max(vPos.y - fSwayStartHeight, 0.f);
	fBendScale = fBendScale * fBendScale * 0.001;
	float fLength = length(vPos);
	float3 vNewPos = vPos;
	float vWave = SmoothTriangleWave(float4(fFreq * (fTime + fPhase), 0.0, 0.0, 0.0)).x;
	vWave = vWave * 2.0 - 1.0;
	vNewPos.xz += vWave * vWindParams.xz * vWindParams.w * fBendScale * fAmp;
	vPos = normalize(vNewPos) * fLength;
}

void _LeafShaking(inout float3 vPos, in float fTime, in float4 vWindParams,
		in float fLeafAmp, in float fAmp, in float fFreq)
{
	float2 vWavesIn = fTime + dot(vPos.xyz, 1.f);
	float4 vWaves = vWavesIn.xyxy * float4(1.975, 0.793, 0.0, 0.0) * fFreq;
	vWaves = TriangleWave(vWaves);
	vPos.xz += vWaves.xy * vWindParams.xz * vWindParams.w * fLeafAmp * fAmp;
}

struct VS_INPUT
{
	float3 i_Pos		: POSITION0;	// xyz: leaf position
#ifdef VERTEX_COLOR
	float4 i_Diffuse	: COLOR0;
#endif
#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		float2 i_UV		: TEXCOORD0;
	#endif
#else
	float3 i_Normal		: NORMAL0;		// xyz: leaf normal
	float2 i_UV			: TEXCOORD0;
#endif

#ifdef BILLBOARD_LEAF
	float4 i_Offset		: TEXCOORD1;	// xy: rotation, z: jitter, w: size for billboard leaf
#endif

#ifdef HWSKINNED
	float4 i_BlendWeight	: BLENDWEIGHT0;
	uint4 i_BlendIndices	: BLENDINDICES0;
#endif	
};

struct VS_OUTPUT
{
	float4 o_PosInClip	: SV_POSITION;
#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		float2 o_UV		: TEXCOORD0;
	#endif
#else
	float3 o_Normal		: NORMAL0;
#ifdef VERTEX_COLOR
	float3 o_Diffuse	: COLOR0;
#endif
	float2 o_UV			: TEXCOORD0;
	float4 o_WorldPos	: TEXCOORD1;
	float4 o_FogColor	: TEXCOORD2;

#ifdef SOFTBORDER
	float4 o_ClipPos	: TEXCOORD3;
#endif
#endif
#ifdef PARABOLOID_MAPPING
	float	o_ClipDepth			: TEXCOORD12;
#endif
	float4	o_PosInModel		: TEXCOORD13;
	float4  o_BoundBoxRange		: TEXCOORD14;
};

#ifdef SKINNEDINSTANCE
	float3x4 loadBoneMatrix (uint animationData , uint index)
	{
		float3x4 rvt ;

		rvt[0] = S_2DExt0.Load(uint3(index*3 + 0, animationData, 0));
		rvt[1] = S_2DExt0.Load(uint3(index*3 + 1, animationData, 0));
		rvt[2] = S_2DExt0.Load(uint3(index*3 + 2, animationData, 0));
		return rvt ;
	}
#endif

VS_OUTPUT main(VS_INPUT IN, uint i_InstanceID : SV_InstanceID)
{
	VS_OUTPUT vsOut = (VS_OUTPUT)0;
	float4 vObjPos = float4(IN.i_Pos.xyz, 1.f);
	vsOut.o_PosInModel = vObjPos;

	#ifdef HWSKINNED
		float4	Weight		= IN.i_BlendWeight;
		uint4  Index		= IN.i_BlendIndices;

		float4 BoneMatC0 = float4(0.0, 0.0, 0.0, 0.0);
		float4 BoneMatC1 = float4(0.0, 0.0, 0.0, 0.0);
		float4 BoneMatC2 = float4(0.0, 0.0, 0.0, 0.0);

		#ifdef SKINNEDINSTANCE
		   	// recalculate index
		   	uint 	animationData = U_VSCustom1[i_InstanceID >> 2][i_InstanceID & 3];
			for(int i=0;i<4;++i)
			{
		     	float3x4 res=loadBoneMatrix(animationData,Index[i]);
		     	BoneMatC0 += Weight[i] * res[0];
			 	BoneMatC1 += Weight[i] * res[1];
			 	BoneMatC2 += Weight[i] * res[2];
			}
		#else
			for(int i=0;i<4;++i)
			{
				int idx = Index[i];
				BoneMatC0	+=	U_BoneMatrix[idx*3+0]*Weight[i];	
				BoneMatC1	+=	U_BoneMatrix[idx*3+1]*Weight[i];	
				BoneMatC2	+=	U_BoneMatrix[idx*3+2]*Weight[i];	
			}
		#endif
		vObjPos = float4(dot(BoneMatC0, vObjPos), dot(BoneMatC1, vObjPos), dot(BoneMatC2, vObjPos), 1.f);
	#endif

	float3x4 matWorld = (float3x4)0;
	float4x4 matInvTransposeWorld = (float4x4)0;
	float4x4 matRotation = (float4x4)0;
	float4x4 matWVP = (float4x4)0;
	float4 vWindParamsObjSpace = float4(1.f, 0.f, 0.f, 1.f);
	
#ifdef USEINSTANCE
	int idxInst = i_InstanceID * UniformCount;

	float3 vPosition =    U_VSCustom0[idxInst + 0];
	float3 vScale =       U_VSCustom0[idxInst + 1];
	float4 vOrientation = U_VSCustom0[idxInst + 2];

	#ifdef SKINNEDINSTANCE
		float3 vMVPosition = vPosition;
		vPosition.x += U_VS_CameraPosition.x;
		vPosition.y += U_VS_CameraPosition.y;
		vPosition.z += U_VS_CameraPosition.z;

		float4x4 _matWorld = MakeTransform( vMVPosition.xyz, vScale.xyz, vOrientation);

		matWorld[0] = _matWorld[0];
		matWorld[1] = _matWorld[1];
		matWorld[2] = _matWorld[2];
		// translate to world space
		matWorld[0][3] += U_VS_CameraPosition.x;
		matWorld[1][3] += U_VS_CameraPosition.y;
		matWorld[2][3] += U_VS_CameraPosition.z;
	#else
		float3 vMVPosition = vPosition;
		vMVPosition.x -= U_VS_CameraPosition.x;
		vMVPosition.y -= U_VS_CameraPosition.y;
		vMVPosition.z -= U_VS_CameraPosition.z;

		float4x4 _matWorld = MakeTransform( vPosition.xyz, vScale.xyz, vOrientation);
		matWorld[0] = _matWorld[0];
		matWorld[1] = _matWorld[1];
		matWorld[2] = _matWorld[2];
		// translate to camera space
		_matWorld[0][3] -= U_VS_CameraPosition.x;
		_matWorld[1][3] -= U_VS_CameraPosition.y;
		_matWorld[2][3] -= U_VS_CameraPosition.z;
	#endif

	matRotation = MakeRotation(vOrientation);
	#ifdef BILLBOARD_LEAF
		// translate to camera space and discard rotation
		_matWorld = MakeTransform(vMVPosition.xyz,
				vScale.xyz, float4(0.f, 0.f, 0.f, 1.f));

		vWindParamsObjSpace = U_WindParams;
	#else
		// transform wind parameters from world space to object space
		vWindParamsObjSpace = mul(transpose(matRotation), U_WindParams);
	#endif

	matInvTransposeWorld = MakeInverseTransform(vPosition.xyz, vScale.xyz, vOrientation);
	matInvTransposeWorld = transpose(matInvTransposeWorld);
	matWVP = mul(float4x4(U_ZeroViewProjectMatrix), _matWorld);

#else
	matWorld[0] = U_WorldMatrix[0];
	matWorld[1] = U_WorldMatrix[1];
	matWorld[2] = U_WorldMatrix[2];

	matInvTransposeWorld[0] = U_InvTransposeWorldMatrix[0];
	matInvTransposeWorld[1] = U_InvTransposeWorldMatrix[1];
	matInvTransposeWorld[2] = U_InvTransposeWorldMatrix[2];

	#ifdef BILLBOARD_LEAF
		matRotation[0] = U_WorldRotationMatrix[0];
		matRotation[1] = U_WorldRotationMatrix[1];
		matRotation[2] = U_WorldRotationMatrix[2];

		matWVP[0] = U_WorldViewProjectNoRotationMatrix[0];
		matWVP[1] = U_WorldViewProjectNoRotationMatrix[1];
		matWVP[2] = U_WorldViewProjectNoRotationMatrix[2];
		matWVP[3] = U_WorldViewProjectNoRotationMatrix[3];

		vWindParamsObjSpace = U_WindParams;
	#else
		matWVP[0] = U_WorldViewProjectMatrix[0];
		matWVP[1] = U_WorldViewProjectMatrix[1];
		matWVP[2] = U_WorldViewProjectMatrix[2];
		matWVP[3] = U_WorldViewProjectMatrix[3];

		vWindParamsObjSpace = U_WindParamsObjSpace;
	#endif
#endif

#ifdef BILLBOARD_LEAF
	vObjPos.xyz = mul((float3x4)matRotation, vObjPos);
	
	float3 vUnitOffset = U_ViewRightVector.xyz * IN.i_Offset.xxx + 
						 U_ViewUpVector.xyz * IN.i_Offset.yyy + 
						 U_ViewDirection.xyz * IN.i_Offset.zzz;
	vObjPos.xyz += vUnitOffset * IN.i_Offset.www;
#endif

	float fBendPhase = matWorld[0][3] + matWorld[1][3] + matWorld[2][3];
	_TrunkBending(vObjPos.xyz, U_VSGeneralRegister0.x, U_VS_Time.x, fBendPhase,
			vWindParamsObjSpace, U_VSGeneralRegister1.x, U_VSGeneralRegister1.y);
	
	float fLeafAmp = 1.f;
#ifdef VERTEX_COLOR
	fLeafAmp = IN.i_Diffuse.a;
#endif
	_LeafShaking(vObjPos.xyz, U_VS_Time.x, vWindParamsObjSpace,
			fLeafAmp, U_VSGeneralRegister1.z, U_VSGeneralRegister1.w);
	
	vsOut.o_PosInClip = mul(matWVP, vObjPos);

#ifdef PARABOLOID_MAPPING
	vsOut.o_ClipDepth = vsOut.o_PosInClip.z;
	ParaboloidMapping(vsOut.o_PosInClip, U_ShadowLightDepthMulAdd.x, U_ShadowLightDepthMulAdd.z, U_ShadowLightDepthMulAdd.w);
#endif

#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		vsOut.o_UV = IN.i_UV;
	#endif

	#ifndef PARABOLOID_MAPPING
		//depthclamp
		vsOut.o_PosInClip.z = ClampToNearPlane(vsOut.o_PosInClip.z);
	#endif

#else
	#ifdef HWSKINNED
		float3 vNormalHWSkinned = float3(dot(BoneMatC0.xyz, IN.i_Normal),
				                         dot(BoneMatC1.xyz, IN.i_Normal),
										 dot(BoneMatC2.xyz, IN.i_Normal));
		IN.i_Normal.xyz = lerp(IN.i_Normal.xyz, vNormalHWSkinned, U_VSGeneralRegister0.y);
	#endif

	vsOut.o_Normal.xyz = mul(matInvTransposeWorld, float4(IN.i_Normal.xyz, 0.f));

	#ifdef VERTEX_COLOR
		vsOut.o_Diffuse.rgb = pow(IN.i_Diffuse.rgb, 2.2f);
	#endif
	
	vsOut.o_UV = IN.i_UV;

	#ifdef SOFTBORDER
		vsOut.o_ClipPos = vsOut.o_PosInClip;
	#endif

	vsOut.o_WorldPos.xyz = mul(matWorld, float4(IN.i_Pos, 1.f));
	vsOut.o_WorldPos.w = 1.f;

	float3 vCamToWPos = U_VS_CameraPosition.xyz - vsOut.o_WorldPos.xyz;

	float4x4 gravityRotatePosMatrix;
	gravityRotatePosMatrix[0] = U_VS_GravityRotationMatrix[0];
	gravityRotatePosMatrix[1] = U_VS_GravityRotationMatrix[1];
	gravityRotatePosMatrix[2] = U_VS_GravityRotationMatrix[2];
	gravityRotatePosMatrix[3] = U_VS_GravityRotationMatrix[3];
	vCamToWPos = mul(gravityRotatePosMatrix,float4(vCamToWPos.xyz,0.0f)).xyz;
	
	vsOut.o_FogColor = ComputeFogColor(vCamToWPos, U_FogParam.xy, U_FogParam.zw, U_FogRampParam, U_FogColorNear, U_FogColorFar);

	#ifdef EDITOR_MODE
		#ifdef HierarchicalLOD
			vsOut.o_PosInClip = float4(2.0f * IN.i_UV.x - 1.0f, 1.0f - 2.0f * IN.i_UV.y, 1.0f, 1.0f);
		#endif
	#endif
#endif
#ifndef SHADOWPASS
	vsOut.o_BoundBoxRange.x = U_VSGeneralRegister7.x;//dot(matWorld[1], float4(0.0f, U_VSGeneralRegister7.x, 0.0f, 1.0f));
	vsOut.o_BoundBoxRange.y = U_VSGeneralRegister7.y;//dot(matWorld[1], float4(0.0f, U_VSGeneralRegister7.y, 0.0f, 1.0f));
	vsOut.o_BoundBoxRange.z = U_VSGeneralRegister7.z;
	vsOut.o_BoundBoxRange.w = U_VSGeneralRegister7.w;
#endif
	return vsOut;
}
