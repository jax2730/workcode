#include <Common_Uniform_VS.inl>
#include <Common_Function.inl>

layout(binding = 2) uniform UniformBlock_Private_VS
{
	vec4 	U_WorldViewProjectMatrix[4];

	vec4 	U_VSGeneralRegister0;				// x: sway frequency, y: sway amplitude, z: shake frequency, w: shake amplitude

	vec4 	U_VSGeneralRegister1;				// xyz:  Box half size
	vec4 	U_VSGeneralRegister2;				// x: Penetrate Beg, y: Penetrate End
	vec4 	U_VSGeneralRegister3;				// xyz:  Box center

	vec4 	U_VSGeneralRegister4;				// x: fade start, y: 1 / fadedist, z: fade end; w: role push ratio	

	vec4 	U_VSCustom0; 						// sphWorldPos;
	vec4 	U_VSCustom1; 						// RoleCamSpaPos;	
	vec4 	U_VSCustom2; 						// xy: VegBound MinY/MaxY, zw: scale base/scale range

	vec4 	U_VSCustom3; 						// vegSpaToCam;

	vec4 	U_VSCustom5; 						// uvPercent
};


// Get a quaternion inverse
vec4 quaternion_inverse(in vec4 quat)
{
	float fNorm = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;
	float fInvNorm = 1.0f/fNorm;
	return vec4( -quat.xyz * fInvNorm, quat.w * fInvNorm);
}

// Rotate a vector with quaternion
vec3 quaternion_mul(in vec4 quat, in vec3 v)
{
	vec3 uv = cross(quat.xyz, v);
	vec3 uuv = cross(quat.xyz, uv);
	uv *= 2.f * quat.w;
	uuv *= 2.f;
	return v + uv + uuv;
}

// generate a triangle wave from a linear wave, range: 0~1
float TriangleWave(float fValue)
{
	return abs(fract(fValue) * 2.0 - 1.0);
}

vec4 getQuatFormAngleAxis(float angle, vec3 axis)
{
	vec4 retQuat = vec4(0.f, 0.f, 0.f, 0.f);
	float halfAngle = angle * 0.5f;
	float fSin = sin(halfAngle);

	retQuat.w = cos(halfAngle);
	retQuat.x = fSin*axis.x;
	retQuat.y = fSin*axis.y;
	retQuat.z = fSin*axis.z;
	return retQuat;
}

vec2 getUVIndexPercent(vec2 uv, float r, vec4 percent)
{
	r -= percent.x;
	if (r < 0.f) return uv;

	r -= percent.y;
	if (r < 0.f) return vec2(uv.x + 0.5f, uv.y);
	
	r -= percent.z;
	if (r < 0.f) return vec2(uv.x, uv.y + 0.5f);
	
	r -= percent.w;
	if (r < 0.f) return vec2(uv.x + 0.5f, uv.y + 0.5f);

	return uv;
}

//	VS_INPUT
layout(location = 0) in vec3 POSITION0;
layout(location = 1) in vec3 NORMAL0;
layout(location = 2) in vec3 TANGENT0;
layout(location = 3) in vec2 TEXCOORD0;
layout(location = 4) in vec4 COLOR0;

layout(location = 5) in vec4 POSITION1;								//	xyz: ins world pos, w: scale
layout(location = 6) in vec4 NORMAL1;								//	rotate quaternion 

//	VS_OUTPUT
// layout(location = 0) out vec4 o_PosInClip;
layout(location = 0) out vec4 o_UV;									//	z: for camera spec pos; 
layout(location = 1) out vec4 o_Fog;
layout(location = 2) out vec4 o_WPos;								//	xyz: world pos
layout(location = 3) out vec3 o_WNormal;
layout(location = 4) out vec4 o_Diffuse;
layout(location = 5) out vec4 o_FadeFac;								//	x: common, y: fade out, z: fade in, w: penetrate value

#ifdef BUMP_MAP
	layout(location = 6) out vec3 o_Tangent;
	layout(location = 7) out vec3 o_Binormal;
#endif

#ifdef USESHADOWMAP
	#include <Common_ShadowProjection_VS.inl>
	layout(location = 8) out vec4    	o_LightSpacePos[SHADOWSPLITE];
#endif

void main()
{
	//	Get vegetation base data	
	//	----------------------------------------------------------
	vec3 RolePushPos = U_VSCustom1.xyz;										//	role cam position
	vec3 vVegRoot =  POSITION1.xyz;											

	vec3 vMeshPos = POSITION0;												//	veg mesh space position
	vec3 vMeshCenP= U_VSGeneralRegister3.xyz;								//	veg mesh center position in veg space		
	vec3 vMeshNor = NORMAL0;												//	veg mesh space normal
	vec4 vMeshQua = NORMAL1 * 2.f - 1.f;									//	veg rotate quaternion
	float vMeshHeightFactor = (POSITION0.y - U_VSCustom2.x) / (U_VSCustom2.y - U_VSCustom2.x);
	//	----------------------------------------------------------
	o_Diffuse.xyz = COLOR0.xyz;
	o_Diffuse.w = vMeshHeightFactor;

	//	Veg mesh random rotate
	vec4 rotateQuat = getQuatFormAngleAxis(POSITION1.w * 3.1415926, vec3(0.f, 1.f, 0.f));
	vMeshPos = quaternion_mul(rotateQuat, vMeshPos);
	vMeshNor  = quaternion_mul(rotateQuat, vMeshNor);
	vMeshCenP = quaternion_mul(rotateQuat, vMeshCenP);

	//	Add veg wind animation
	//	----------------------------------------------------------
#ifdef WIND_ANIMATION
	vec4 vAnimParams = U_VSGeneralRegister0 * U_GlobalAnimationParams.yxwz;
	vec2 vWaveBase = vec2(vAnimParams.x * U_VS_Time.x);
	vWaveBase += vVegRoot.xz * vec2(0.1f, 0.2f);							//	each veg have diff wave form root pos
	vec3 vWave = vWaveBase.xyy * vec3(1.125f, 0.975f, 0.397f);
	vWave = sin(vWave);

	// swaying
	float swayFactor = vMeshHeightFactor;
	float fSway = vAnimParams.y * swayFactor * swayFactor;

	// Get scene wind dir
	vec4 vQuaInv = quaternion_inverse(vMeshQua);
	vec3 windMeshSpaceDir = quaternion_mul(vQuaInv, U_WindParams.xyz);

	vec3 vOff = vec3(0.f, 0.f, 0.f);
	vOff.xz += windMeshSpaceDir.xz * vWave.x * fSway;										
	vOff.xz += (vec2(-windMeshSpaceDir.z, windMeshSpaceDir.x)) * vWave.y * vWave.z * fSway;	// perpendicular wind direction

	// shaking
	float fShakeFreq = vAnimParams.z * U_VS_Time.x;
	fShakeFreq += dot(vMeshPos, vec3(2.0));	// phase
	float fShakeAmp = vAnimParams.w * swayFactor * swayFactor;
	vOff += normalize(vMeshNor + windMeshSpaceDir.xyz) * TriangleWave(fShakeFreq) * fShakeAmp;

	// push by role
	vec3 vRoleToVeg = vVegRoot +  U_VSCustom3.xyz - RolePushPos.xyz;
	float fRoleToVegLen = length(vRoleToVeg);

	vec3 RoleToVegMeshSpaceDir = quaternion_mul(vQuaInv, normalize(vRoleToVeg));	
	RoleToVegMeshSpaceDir = normalize(RoleToVegMeshSpaceDir);
	vec2 vegPushDir = RoleToVegMeshSpaceDir.xz;		// push direction

	float fPushLen = clamp(U_VSGeneralRegister4.w - fRoleToVegLen, 0.0f, U_VSGeneralRegister4.w);
	float fLenFactor = 1.0f - clamp(fPushLen / U_VSGeneralRegister4.w, 0.0f, 1.0f);
	fLenFactor = min(fLenFactor * 5.0f, 1.0f);
	vOff.xz += vegPushDir * vMeshPos.y * fPushLen * fLenFactor;

	float fLen = length(vMeshPos);
	vMeshPos += vOff;
	vMeshPos = normalize(vMeshPos) * fLen;
#endif
	//	----------------------------------------------------------

	//	Vegetation fade
	//	----------------------------------------------------------
	vec3 vCamToVeg = vVegRoot +  U_VSCustom3.xyz;
	float fLenCV = length(vCamToVeg);	

	//	limit show range
	vMeshPos *= fLenCV > U_VSGeneralRegister4.z ? 0.f : 1.f;

	float fFadeFar = (fLenCV - U_VSGeneralRegister4.x) * U_VSGeneralRegister4.y;
	fFadeFar = clamp(fFadeFar, 0.f, 1.f);
	o_FadeFac = vec4(1.f, fFadeFar, 1.f, 1.f);
	//	----------------------------------------------------------

	//	Mesh scale
	float realScale = U_VSCustom2.z + U_VSCustom2.w * POSITION1.w;
	vMeshPos *= realScale;
	vMeshCenP *= realScale;

	// rotate to mesh normalize
	vMeshPos = quaternion_mul(vMeshQua, vMeshPos);
	vMeshNor  = quaternion_mul(vMeshQua, vMeshNor);
	vMeshCenP = quaternion_mul(vMeshQua, vMeshCenP);
	o_WNormal = vMeshNor;

	vec3 vMeshWorldPos = vMeshPos + vVegRoot + U_VSCustom0.xyz;
	o_WPos.xyz = vMeshWorldPos;
	o_WPos.w = 1.f;

	vec4 vPosObj = vec4(vMeshPos + (vVegRoot + U_VSCustom3.xyz), 1.f);
	vec4 posInClip;
	posInClip.x = dot(U_WorldViewProjectMatrix[0], vPosObj);
	posInClip.y = dot(U_WorldViewProjectMatrix[1], vPosObj);
	posInClip.z = dot(U_WorldViewProjectMatrix[2], vPosObj);
	posInClip.w = dot(U_WorldViewProjectMatrix[3], vPosObj);
	gl_Position = posInClip;

	//	----------------------------------------------------------
	o_UV.xy = getUVIndexPercent(TEXCOORD0.xy, POSITION1.w / 2.f + 0.5f, U_VSCustom5);
	//	----------------------------------------------------------

	//	Penetrate about
	//	----------------------------------------------------------
	float vegRealHalfSize = length(U_VSGeneralRegister1.xyz) * realScale;
	vec3 camSpaceCenP = vVegRoot + vMeshCenP + U_VSCustom3.xyz;
	float camDisToCenP = length(camSpaceCenP);
	float disProportion = camDisToCenP / vegRealHalfSize;
	o_FadeFac.w  = clamp((U_VSGeneralRegister2.y - disProportion) / (U_VSGeneralRegister2.y - U_VSGeneralRegister2.x), 0.0, 1.0);

#ifdef BUMP_MAP
	vec3 vMeshTangent = TANGENT0.xyz;
	vMeshTangent  = quaternion_mul(rotateQuat, vMeshTangent);
	vMeshTangent = quaternion_mul(vMeshQua, vMeshTangent);
	vec3 vMeshBinormal = cross(vMeshTangent, vMeshNor);

	o_Tangent = vMeshTangent;
	o_Binormal = vMeshBinormal;
#endif

	//	Fog 
	{
		vec3 vCamToWorld = -(vMeshPos + (vVegRoot + U_VSCustom3.xyz));

		vec3 camToWorldTemp = vCamToWorld;	
		vCamToWorld.x = dot(U_VS_GravityRotationMatrix[0].xyz, camToWorldTemp);
		vCamToWorld.y = dot(U_VS_GravityRotationMatrix[1].xyz, camToWorldTemp);
		vCamToWorld.z = dot(U_VS_GravityRotationMatrix[2].xyz, camToWorldTemp);
		
		o_Fog = ComputeFogColor(vCamToWorld,U_FogParam.xy,U_FogParam.zw,U_FogRampParam,U_FogColorNear,U_FogColorFar);
	}

#ifdef USESHADOWMAP
	// Shadow map - use camera-relative position (vPosObj) with U_LightVPMatrixView for stability
	vec4 wpos = vPosObj;  // camera-relative position: vMeshPos + (vVegRoot + U_VSCustom3.xyz)
	#if SHADOWSPLITE > 0
		o_LightSpacePos[0].x = dot(U_LightVPMatrixView0[0], wpos);
		o_LightSpacePos[0].y = dot(U_LightVPMatrixView0[1], wpos);
		o_LightSpacePos[0].z = dot(U_LightVPMatrixView0[2], wpos);
		o_LightSpacePos[0].w = dot(U_LightVPMatrixView0[3], wpos);
		o_LightSpacePos[0].xy = o_LightSpacePos[0].xy * 0.5 + 0.5;
	#endif

	#if SHADOWSPLITE > 1
		o_LightSpacePos[1].x = dot(U_LightVPMatrixView1[0], wpos);
		o_LightSpacePos[1].y = dot(U_LightVPMatrixView1[1], wpos);
		o_LightSpacePos[1].z = dot(U_LightVPMatrixView1[2], wpos);
		o_LightSpacePos[1].w = dot(U_LightVPMatrixView1[3], wpos);
		o_LightSpacePos[1].xy = o_LightSpacePos[1].xy * 0.5 + 0.5;
	#endif

	#if SHADOWSPLITE > 2
		o_LightSpacePos[2].x = dot(U_LightVPMatrixView2[0], wpos);
		o_LightSpacePos[2].y = dot(U_LightVPMatrixView2[1], wpos);
		o_LightSpacePos[2].z = dot(U_LightVPMatrixView2[2], wpos);
		o_LightSpacePos[2].w = dot(U_LightVPMatrixView2[3], wpos);
		o_LightSpacePos[2].xy = o_LightSpacePos[2].xy * 0.5 + 0.5;
	#endif

	#if SHADOWSPLITE > 3
		o_LightSpacePos[3].x = dot(U_LightVPMatrixView3[0], wpos);
		o_LightSpacePos[3].y = dot(U_LightVPMatrixView3[1], wpos);
		o_LightSpacePos[3].z = dot(U_LightVPMatrixView3[2], wpos);
		o_LightSpacePos[3].w = dot(U_LightVPMatrixView3[3], wpos);
		o_LightSpacePos[3].xy = o_LightSpacePos[3].xy * 0.5 + 0.5;
	#endif

	o_UV.z = -dot(U_MainCamViewMatrix, o_WPos);
#endif
}