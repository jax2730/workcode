# 大世界浮点精度问题 - 项目进度报告

**日期**: 2025-10-24  
**项目**: Echo Engine Camera-Relative 坐标系修复  
**状态**: 🔄 进行中 - CPU层诊断阶段

---

## 📋 目录

1. [问题概述](#问题概述)
2. [技术背景](#技术背景)
3. [问题诊断历程](#问题诊断历程)
4. [已完成的修改](#已完成的修改)
5. [当前问题分析](#当前问题分析)
6. [下一步计划](#下一步计划)
7. [关键代码修改记录](#关键代码修改记录)
8. [日志分析](#日志分析)

---

## 问题概述

### 问题描述
在大世界场景中（坐标达到 7 位数，如 `-365472, 432224`），由于 `float` 精度限制（23位尾数，约7-8位有效数字），导致：
- **地形和植被完全不可见**
- **物体抖动**（顶点位置在整数间跳变）
- **贴图错位**（UV计算不准）
- **法线闪烁**（法线空间计算误差）

### 预期目标
通过 **Camera-Relative 坐标系**技术，将所有坐标转换为相对于摄像机的小坐标（几百范围内），从而：
- ✅ 消除精度损失
- ✅ 保持渲染质量
- ✅ 支持无限大世界

---

## 技术背景

### Camera-Relative 原理

#### 传统坐标系
```
世界坐标 = (-365472, 200, 432224)  ← 大数值，float 精度损失
```

#### Camera-Relative 坐标系
```
1. 设置世界原点 WorldOrigin = (-366000, 0, 432000)
2. 相对坐标 = 世界坐标 - WorldOrigin
   = (-365472, 200, 432224) - (-366000, 0, 432000)
   = (528, 200, 224)  ← 小数值，精度完美！
```

### 数学原理

#### 世界矩阵变换
```
原始：W = [R | t]
CR后：W' = [R | t - c]  // c = camera position
```

#### View 矩阵变换
```
原始：V = [R^T | -R^T·c]
CR后：V' = [R^T | 0]  // 摄像机在原点，平移为0
```

#### 完整变换链
```
p_clip = P · V' · W' · p_local
       = P · [R^T | 0] · [R | t-c] · p_local
       = P · V · W · p_local  // T^-1 · T = I，数学上等价！
```

---

## 问题诊断历程

### 第1阶段：初始问题 (截图：只有天空)

**现象**：
- 画面只显示天空
- 地形、植被、人物全部消失
- 坐标显示：`(-365472.0, 6.8, 432214.4)`

**初步诊断**：
```
[TERRAIN] CamPos=(-365472.0,9.7,432224.0) mOriginPos=(-1731152.0,0.0,-1480576.0)
          ↑ 大坐标                          ↑ 地形原点

距离 = sqrt((365472-1731152)^2 + (432224-1480576)^2) ≈ 2000 km
→ 全部被视锥剔除！
```

---

### 第2阶段：GPU Camera-Relative 测试

**尝试1：在 GPU 层源头统一处理**

修改 `EchoGpuParamsManager.cpp:729-765`：
```cpp
// 在 commitUniformParams 中统一处理
DBMatrix4 T_CR, T_INV_CR;
T_CR.makeTransform(-camPos, ...);      // T = [I | -c]
T_INV_CR.makeTransform(camPos, ...);   // T^-1 = [I | c]

DBMatrix4 worldCR = T_CR * (*m_pWorldMatrix);     // W' = T · W
DBMatrix4 invWorldCR = (*mInvWorldMatrix) * T_INV_CR; // invW' = invW · T^-1

m_pWorldMatrix = &worldCR;
mInvWorldMatrix = &invWorldCR;
```

**问题**：
- ❌ 局部变量 `worldCR` 在函数返回后被销毁
- ❌ 指针悬空（dangling pointer）
- ❌ 所有物体共用同一个 `static` 矩阵（最后一个覆盖前面的）

**决策**：
- 🔄 暂时关闭 GPU camera-relative（`g_EnableGpuCameraRelative = false`）
- 🔍 先诊断 CPU 层的问题

---

### 第3阶段：CPU 层诊断

#### 问题发现：WorldOrigin Rebasing 机制已存在

**EchoMiniMap.cpp:1231-1299**：
```cpp
void MiniMapManager::Tick() {
    // 检测摄像机距离世界原点超过 10km，触发 rebasing
    DVector3 currentOrigin = Root::instance()->getWorldOrigin();
    DVector3 cameraPosD(mPlayerWorldPosition);
    DVector3 offset = cameraPosD - currentOrigin;
    
    if (s_firstRebase || offset.squaredLength() > 10000.0 * 10000.0) {
        // 将世界原点设置到摄像机附近
        DVector3 newOrigin(
            floor(cameraPosD.x / 1000.0) * 1000.0,
            0.0,
            floor(cameraPosD.z / 1000.0) * 1000.0
        );
        Root::instance()->changeWorldOrigin(newOrigin);  // 调用重定位
    }
}
```

**EchoKarstGroup.cpp:478-530**：
```cpp
void KarstGroup::worldOriginRebasing(double origin_x, double origin_y, double origin_z) {
    DVector3 offset = DVector3(origin_x, origin_y, origin_z) - mWorldBasePosition;
    
    // 更新地形基准位置
    mWorldBasePosition = DVector3(origin_x, origin_y, origin_z);
    updateWorldBasePosition();
    
    // 更新摄像机位置
    Camera* mainCam = mSceneManager->getMainCamera();
    if (mainCam) {
        DVector3 oldCamPos = mainCam->getPosition();
        DVector3 newCamPos = oldCamPos - offset;  // 转换为相对坐标
        mainCam->setPosition(newCamPos);
    }
}
```

**日志证据**：
```
15:02:12: [WorldOrigin Rebase] FirstTime=1 Dist=566.0km 
          OldOrigin=(0.0,0.0,0.0) NewOrigin=(-366000.0,0.0,432000.0) 
          Cam=(-365472.0,197.1,432214.4)
          
15:02:12: ========== [KarstGroup::worldOriginRebasing] CALLED! ==========
15:02:12: [KarstGroup::worldOriginRebasing] MainCamera OldPos=(-365472.0,200.0,432224.0) 
                                             NewPos=(528.0,200.0,224.0)
          ↑ 摄像机成功更新为小坐标！✅
```

---

### 第4阶段：发现关键问题 - 摄像机被外部系统覆盖

**17秒后的日志**：
```
15:02:29: [WorldOrigin Check] Frame=60 
          CurrentOrigin=(-366000.0,0.0,432000.0) 
          CamPos=(-365472.0,6.8,432214.4)  ← 又变回大坐标！❌
          Offset=(528.0,6.8,214.4) Dist=0.6km

15:02:29: [TERRAIN] Frame=60 CamPos=(-365472.0,9.7,432224.0)
          ↑ 确认：摄像机又是大坐标
```

**根本原因分析**：

```
时间线：
┌─────────────────────────────────────────────────────────────┐
│ 15:02:12  worldOriginRebasing 回调                          │
│           ├─ 设置 WorldOrigin = (-366000, 0, 432000)        │
│           └─ 更新摄像机 → (528, 200, 224)  ✅               │
├─────────────────────────────────────────────────────────────┤
│ 15:02:12  帧末，worldOriginRebasing 执行完成                │
├─────────────────────────────────────────────────────────────┤
│ 15:02:13  下一帧开始                                         │
│           外部系统（角色控制器？）更新摄像机                 │
│           ├─ 读取 mPlayerWorldPosition = (-365472, 6.8, ...) │
│           └─ camera->setPosition(mPlayerWorldPosition)      │
│               ↑ 直接用大坐标设置！覆盖了小坐标！❌          │
├─────────────────────────────────────────────────────────────┤
│ 15:02:29  Frame=60                                           │
│           摄像机 = (-365472, 9.7, 432224)  ← 又是大坐标     │
│           地形距离 ≈ 2000 km → 视锥剔除 → 不可见 ❌        │
└─────────────────────────────────────────────────────────────┘
```

**关键理解**（用户纠正）：

> `mPlayerWorldPosition = (-365472, 6.8, 432214)` 是玩家在**整个大地图**中的真实位置（世界坐标）。
> 这个值**应该保持不变**！
> 
> 如果改成小坐标 `(528, 6.8, 214)`，人物就会跑到地图的 (528, 6.8, 214) 点，而不是正确的 (-365472, 6.8, 432214) 位置！

**错误尝试**（已撤销）：
```cpp
// ❌ 错误：修改了 mPlayerWorldPosition
mPlayerWorldPosition -= Vector3(originDelta);  // 从 (-365472) 变成 (528)
// 这会导致：
// 1. 外部系统用 (528) 设置摄像机 → 人物位置错误
// 2. 地图 UI 显示错误的坐标
// 3. 逻辑混乱
```

---

## 已完成的修改

### 1. EchoGpuParamsManager.cpp

#### 修改1：关闭 GPU Camera-Relative（测试用）
```cpp
// 第44行
static bool g_EnableGpuCameraRelative = false; // [CR TEST] 暂时关闭，只测试 CPU 层
```

#### 修改2：注释掉源头统一处理（避免指针悬空）
```cpp
// 第729-737行
// [CR] Camera-Relative 矩阵变换（源头统一处理）
// [CR NOTE] 暂时注释掉源头处理，改为在各 uniform case 中单独处理（避免指针悬空）
/*
if (g_EnableGpuCameraRelative) {
    // 问题：局部变量 worldCR/invWorldCR 在函数返回后被销毁，导致指针悬空
    // 解决方案：改为在各 uniform case 中处理，或使用成员变量
}
*/
```

---

### 2. EchoMiniMap.cpp

#### 修改1：添加 Tick 调用检测
```cpp
// 第1224-1232行
void MiniMapManager::Tick() {
    // [CR DEBUG] 确认 Tick 被调用
    static int s_tickCount = 0;
    static int s_logInterval = 60;
    if ((++s_tickCount % s_logInterval) == 0) {
        char buf[256];
        sprintf(buf, "[MiniMapManager::Tick] Called! Frame=%d mbInit=%d mbIsCreate=%d", 
            s_tickCount, mbInit ? 1 : 0, mbIsCreate ? 1 : 0);
        LogManager::instance()->logMessage(buf);
    }
    // ...
}
```

#### 修改2：添加 WorldOrigin 检查日志
```cpp
// 第1252-1263行
// [CR DEBUG] 每60帧打印一次检查状态
if ((s_tickCount % 60) == 0) {
    char buf[512];
    sprintf(buf, "[WorldOrigin Check] Frame=%d FirstRebase=%d CurrentOrigin=(%.1f,%.1f,%.1f) CamPos=(%.1f,%.1f,%.1f) Offset=(%.1f,%.1f,%.1f) Dist=%.1fkm Threshold=%.1fkm",
        s_tickCount, s_firstRebase ? 1 : 0,
        currentOrigin.x, currentOrigin.y, currentOrigin.z,
        cameraPosD.x, cameraPosD.y, cameraPosD.z,
        offset.x, offset.y, offset.z,
        sqrt(offset.squaredLength()) / 1000.0,
        rebaseThreshold / 1000.0);
    LogManager::instance()->logMessage(buf);
}
```

#### 修改3：不修改 mPlayerWorldPosition（关键修复）
```cpp
// 第1293-1297行
// [CR NOTE] mPlayerWorldPosition 保持世界坐标（大坐标），不修改！
// 外部系统会继续用大坐标更新，但在使用时需要转换为相对坐标
sprintf(logMsg, "[WorldOrigin Rebase] mPlayerWorldPosition keeps world coords: (%.1f,%.1f,%.1f) [不修改，保持大坐标]",
    mPlayerWorldPosition.x, mPlayerWorldPosition.y, mPlayerWorldPosition.z);
LogManager::instance()->logMessage(logMsg);
```

#### 修改4：UpdatePlayerPosition 保持传入的世界坐标
```cpp
// 用户修改：撤销了自动转换逻辑
void MiniMapManager::UpdatePlayerPosition(const Vector3& InPosition) {
    mPlayerWorldPosition = InPosition;  // 直接保存世界坐标，不转换
}
```

---

### 3. EchoKarstGroup.cpp

#### 修改1：注册监听器时添加日志
```cpp
// 第127-130行
Root::instance()->addWorldOriginListener(this);

// [CR DEBUG] 确认监听器注册成功
char logMsg[256];
sprintf(logMsg, "[KarstGroup::Init] WorldOriginListener registered! this=%p", this);
LogManager::instance()->logMessage(logMsg);
```

#### 修改2：worldOriginRebasing 添加详细日志
```cpp
// 第480-530行
void KarstGroup::worldOriginRebasing(double origin_x, double orign_y, double origin_z) {
    // [CR DEBUG] 首先打印被调用的消息
    char logMsg[512];
    sprintf(logMsg, "========== [KarstGroup::worldOriginRebasing] CALLED! this=%p ==========", this);
    LogManager::instance()->logMessage(logMsg);
    
    // ... 世界原点变更日志 ...
    
    // [CR CRITICAL] 同步更新所有摄像机位置！
    Camera* mainCam = mSceneManager->getMainCamera();
    Camera* activeCam = mSceneManager->getActiveCamera();
    
    sprintf(logMsg, "[KarstGroup::worldOriginRebasing] MainCamera=%p ActiveCamera=%p Same=%d",
        mainCam, activeCam, (mainCam == activeCam) ? 1 : 0);
    LogManager::instance()->logMessage(logMsg);
    
    // 更新主摄像机
    if (mainCam) {
        DVector3 oldCamPos = mainCam->getPosition();
        DVector3 newCamPos = oldCamPos - offset;
        mainCam->setPosition(newCamPos);
        sprintf(logMsg, "[KarstGroup::worldOriginRebasing] MainCamera OldPos=(%.1f,%.1f,%.1f) NewPos=(%.1f,%.1f,%.1f)",
            oldCamPos.x, oldCamPos.y, oldCamPos.z,
            newCamPos.x, newCamPos.y, newCamPos.z);
        LogManager::instance()->logMessage(logMsg);
        
        // [CR DEBUG] 验证设置是否生效
        DVector3 verifyPos = mainCam->getPosition();
        sprintf(logMsg, "[KarstGroup::worldOriginRebasing] MainCamera Verify after setPosition: (%.1f,%.1f,%.1f) [应该等于NewPos]",
            verifyPos.x, verifyPos.y, verifyPos.z);
        LogManager::instance()->logMessage(logMsg);
    }
    
    // 如果 ActiveCamera 不同，也要更新
    if (activeCam && activeCam != mainCam) {
        // ... 同样的更新逻辑 ...
    }
}
```

#### 修改3：findVisibleObjects 添加坐标诊断
```cpp
// 第652-692行
void KarstGroup::findVisibleObjects(const Camera* pCamera, RenderQueue* pQueue) {
    // [CR DEBUG] 地形视锥剔除诊断
    static int s_frameCount = 0;
    static DVector3 s_lastCamPos(0, 0, 0);
    bool debugTerrain = (++s_frameCount % 60) == 0;  // 每60帧打印一次
    
    if (debugTerrain && pCamera == mSceneManager->getMainCamera()) {
        Camera* mainCam = mSceneManager->getMainCamera();
        Camera* activeCam = mSceneManager->getActiveCamera();
        DVector3 camPos = pCamera->getPosition();
        DVector3 worldOrigin = Root::instance()->getWorldOrigin();
        
        char buf[1024];
        sprintf(buf, "[TERRAIN] Frame=%d pCamera=%p MainCam=%p ActiveCam=%p WorldOrigin=(%.1f,%.1f,%.1f) CamPos=(%.1f,%.1f,%.1f) mOriginPos=(%.1f,%.1f,%.1f) mWorldBasePos=(%.1f,%.1f,%.1f) BlocksTotal=%d",
            s_frameCount, pCamera, mainCam, activeCam, 
            worldOrigin.x, worldOrigin.y, worldOrigin.z,
            camPos.x, camPos.y, camPos.z,
            mOriginPosition.x, mOriginPosition.y, mOriginPosition.z,
            mWorldBasePosition.x, mWorldBasePosition.y, mWorldBasePosition.z,
            (int)mKarstBlocks.size());
        LogManager::instance()->logMessage(buf);
        
        // [CR CRITICAL] 检查摄像机坐标是否符合预期
        DVector3 expectedCamRelative = camPos - worldOrigin;
        if (fabs(expectedCamRelative.x) > 10000 || fabs(expectedCamRelative.z) > 10000) {
            sprintf(buf, "[TERRAIN] ⚠️ WARNING: Camera is using WORLD coords! CamPos=(%.1f,%.1f,%.1f) WorldOrigin=(%.1f,%.1f,%.1f) RelativePos=(%.1f,%.1f,%.1f)",
                camPos.x, camPos.y, camPos.z,
                worldOrigin.x, worldOrigin.y, worldOrigin.z,
                expectedCamRelative.x, expectedCamRelative.y, expectedCamRelative.z);
            LogManager::instance()->logMessage(buf);
        }
        
        // [CR DEBUG] 计算摄像机与地形的距离
        DVector3 terrainToCamera = camPos - mOriginPosition;
        double distKm = sqrt(terrainToCamera.squaredLength()) / 1000.0;
        sprintf(buf, "[TERRAIN] TerrainOriginToCamera Distance=%.1fkm [视锥剔除阈值通常<50km]",
            distKm);
        LogManager::instance()->logMessage(buf);
        
        s_lastCamPos = camPos;
    }
    // ...
}
```

---

## 当前问题分析

### 问题确认

**症状**：
```
✅ WorldOrigin Rebasing 机制正常工作
✅ 摄像机在 worldOriginRebasing 中被正确更新为小坐标 (528, 200, 224)
❌ 17秒后摄像机又变回大坐标 (-365472, 9.7, 432224)
❌ 地形距离 2000 km → 视锥剔除 → 不可见
```

**根本原因**：
外部系统（可能是角色控制器、玩家系统）每帧都在用**世界坐标**（大坐标）设置摄像机位置，覆盖了 worldOriginRebasing 的更新。

**推测的调用链**：
```cpp
// 伪代码
void SomeExternalSystem::Update() {
    // 获取玩家世界位置
    Vector3 playerWorldPos = GetPlayerPosition();  // (-365472, 6.8, 432214)
    
    // 计算摄像机位置（跟随玩家）
    Vector3 cameraWorldPos = playerWorldPos + cameraOffset;
    
    // 直接用世界坐标设置摄像机 ← 问题在这里！
    mainCamera->setPosition(cameraWorldPos);  // 每帧都覆盖！
}
```

### 为什么 mPlayerWorldPosition 不能修改

**用户的正确纠正**：

```
mPlayerWorldPosition = (-365472, 6.8, 432214)
  ↑ 这是玩家在整个大地图中的真实位置（世界坐标）

如果修改为相对坐标：
mPlayerWorldPosition = (528, 6.8, 214)
  ↑ 玩家就会跑到地图的 (528, 6.8, 214) 点！
  ↑ 这是错误的！人物应该在 (-365472, 6.8, 432214) 点！

正确的逻辑：
1. mPlayerWorldPosition 始终保存世界坐标（大坐标）
2. 外部系统用世界坐标更新玩家位置和摄像机
3. 在渲染时，摄像机应该使用相对坐标（小坐标）
```

---

## 下一步计划

### 🎯 立即需要做的

#### 1. 运行诊断并收集日志 ⏳

**运行游戏并搜索关键日志**：
```bash
grep -E "\[WorldOrigin Rebase\]|\[KarstGroup::worldOriginRebasing\]|WARNING.*Camera|TERRAIN.*Frame=60" Echo.log
```

**预期看到的信息**：
```
[WorldOrigin Rebase] mPlayerWorldPosition keeps world coords: (-365472,197,432214)
[KarstGroup::worldOriginRebasing] MainCamera NewPos=(528,200,224)
[KarstGroup::worldOriginRebasing] MainCamera Verify: (528,200,224)

[60帧后]
[TERRAIN] ⚠️ WARNING: Camera is using WORLD coords! 
          CamPos=(-365472,9.7,432224) 
          RelativePos=(528,9.7,224)
```

#### 2. 确认外部系统覆盖摄像机的位置 🔍

**需要找到**：
- 哪个系统在每帧更新摄像机？
- 调用 `camera->setPosition()` 的地方
- 是否有角色控制器、玩家系统、摄像机跟随系统？

**可能的文件**：
- `PlayerController.cpp`
- `CharacterController.cpp`
- `CameraFollow.cpp`
- `ActorSystem.cpp`

---

### 🔧 解决方案选项

#### 方案 A：修改 Camera::setPosition（推荐）

**在 Camera 类中自动转换坐标**：

```cpp
// EchoCamera.cpp
void Camera::setPosition(const DVector3& pos) {
    // [CR] 自动转换为相对坐标
    if (Root::instance()->isWorldOriginRebasingEnabled()) {
        DVector3 worldOrigin = Root::instance()->getWorldOrigin();
        DVector3 relativePos = pos - worldOrigin;
        mPosition = relativePos;
        
        // [CR DEBUG] 可选日志
        if (fabs(pos.x) > 100000 || fabs(pos.z) > 100000) {
            static int s_warnCount = 0;
            if ((++s_warnCount % 300) == 0) {
                LogManager::instance()->logMessage(
                    StringUtil::format("[Camera::setPosition] Auto-converted: world=(%.1f,%.1f,%.1f) relative=(%.1f,%.1f,%.1f)",
                    pos.x, pos.y, pos.z, relativePos.x, relativePos.y, relativePos.z)
                );
            }
        }
    } else {
        mPosition = pos;
    }
    
    invalidateView();
}
```

**优点**：
- ✅ 对外部系统透明，无需修改大量代码
- ✅ 集中处理，维护简单
- ✅ 向后兼容

**缺点**：
- ⚠️ 每次 setPosition 都有额外计算（性能影响小）

---

#### 方案 B：找到并修复外部系统

**定位并修改角色控制器**：

```cpp
// 假设在 PlayerController.cpp
void PlayerController::UpdateCamera() {
    Vector3 playerWorldPos = GetPlayerPosition();  // (-365472, 6.8, 432214)
    
    // [CR FIX] 转换为相对坐标
    DVector3 worldOrigin = Root::instance()->getWorldOrigin();
    Vector3 playerRelativePos = playerWorldPos - Vector3(worldOrigin);
    
    Vector3 cameraRelativePos = playerRelativePos + cameraOffset;
    mainCamera->setPosition(cameraRelativePos);  // 用相对坐标设置
}
```

**优点**：
- ✅ 明确控制，逻辑清晰
- ✅ 避免隐式转换

**缺点**：
- ❌ 需要找到所有设置摄像机的地方
- ❌ 可能有多处代码需要修改
- ❌ 容易遗漏

---

#### 方案 C：每帧强制校正摄像机（临时方案）

**在渲染前强制更新**：

```cpp
// EchoKarstGroup.cpp::findVisibleObjects
void KarstGroup::findVisibleObjects(const Camera* pCamera, RenderQueue* pQueue) {
    // [CR WORKAROUND] 强制校正摄像机坐标
    if (pCamera == mSceneManager->getMainCamera()) {
        Camera* mainCam = const_cast<Camera*>(pCamera);  // 去掉 const
        DVector3 camPos = mainCam->getPosition();
        DVector3 worldOrigin = Root::instance()->getWorldOrigin();
        DVector3 relativePos = camPos - worldOrigin;
        
        // 如果摄像机使用的是世界坐标（大坐标），强制转换
        if (fabs(relativePos.x) > 10000 || fabs(relativePos.z) > 10000) {
            mainCam->setPosition(relativePos);  // 强制设置为相对坐标
        }
    }
    
    // ... 原有逻辑 ...
}
```

**优点**：
- ✅ 快速修复，立竿见影
- ✅ 不需要找外部系统

**缺点**：
- ❌ 治标不治本
- ❌ 可能导致摄像机抖动
- ❌ 性能浪费（每帧都检查）

---

## 关键代码修改记录

### 文件清单

| 文件 | 修改内容 | 状态 |
|------|---------|------|
| `EchoGpuParamsManager.cpp` | 关闭 GPU CR，注释源头处理 | ✅ 完成 |
| `EchoMiniMap.cpp` | 添加诊断日志，保持世界坐标 | ✅ 完成 |
| `EchoKarstGroup.cpp` | 添加 rebasing 日志，摄像机验证 | ✅ 完成 |
| `EchoCamera.cpp` | 待修改：自动坐标转换 | ⏳ 待定 |

### Git 状态

```bash
Changes not staged for commit:
  modified:   EchoGpuParamsManager.cpp
  modified:   EchoKarstGroup.cpp
  modified:   EchoMiniMap.cpp

Untracked files:
  Echo.log
  大世界浮点精度_CameraRelative技术方案.md
  大世界浮点精度_项目进度报告.md (本文档)
  调试指南_Camera_Relative_问题诊断.md
```

---

## 日志分析

### 完整日志示例（最新运行）

```
15:01:54: *-*-* ECHO Initialising
15:02:05: [KarstGroup::Init] WorldOriginListener registered! this=000001F510855B90

[初始 Rebasing]
15:02:12: [WorldOrigin Rebase] FirstTime=1 Dist=566.0km 
          OldOrigin=(0.0,0.0,0.0) 
          NewOrigin=(-366000.0,0.0,432000.0) 
          Cam=(-365472.0,197.1,432214.4)
          
15:02:12: [WorldOrigin Rebase] After changeWorldOrigin: 
          before=(0.0,0.0,0.0) after=(-366000.0,0.0,432000.0)
          
15:02:12: [WorldOrigin Rebase] mPlayerWorldPosition keeps world coords: 
          (-365472.0,197.1,432214.4) [不修改，保持大坐标]

[帧末回调]
15:02:12: ========== [KarstGroup::worldOriginRebasing] CALLED! ==========
15:02:12: [KarstGroup::worldOriginRebasing] 
          OldWorldBase=(0.0,0.0,0.0) 
          NewWorldBase=(-366000.0,0.0,432000.0) 
          Offset=(-366000.0,0.0,432000.0)
          
15:02:12: [KarstGroup::worldOriginRebasing] MainCamera=%p ActiveCamera=%p Same=1
15:02:12: [KarstGroup::worldOriginRebasing] MainCamera 
          OldPos=(-365472.0,200.0,432224.0) 
          NewPos=(528.0,200.0,224.0)  ← 成功更新为小坐标！✅

[60帧后 - 问题出现]
15:02:29: [MiniMapManager::Tick] Called! Frame=60 mbInit=1 mbIsCreate=1
15:02:29: [WorldOrigin Check] Frame=60 FirstRebase=0 
          CurrentOrigin=(-366000.0,0.0,432000.0) 
          CamPos=(-365472.0,6.8,432214.4)  ← 又变回大坐标！❌
          Offset=(528.0,6.8,214.4) Dist=0.6km Threshold=10.0km
          
15:02:29: [TERRAIN] Frame=60 
          CamPos=(-365472.0,9.7,432224.0)  ← 确认使用大坐标
          mOriginPos=(-1731152.0,0.0,-1480576.0) 
          mWorldBasePos=(-366000.0,0.0,432000.0) 
          BlocksTotal=10965

[预期但缺失的日志]
15:02:29: [TERRAIN] ⚠️ WARNING: Camera is using WORLD coords!  ← 需要添加
```

### 日志解读

| 时间 | 事件 | 状态 | 说明 |
|------|------|------|------|
| 15:02:05 | KarstGroup 初始化 | ✅ | 监听器注册成功 |
| 15:02:12 | WorldOrigin Rebasing | ✅ | 触发重定位，设置新世界原点 |
| 15:02:12 | 回调更新摄像机 | ✅ | 摄像机更新为小坐标 (528, 200, 224) |
| 15:02:29 | Frame=60 检查 | ❌ | 摄像机又是大坐标 (-365472, 9.7, 432224) |
| - | 距离计算 | ❌ | 地形距离 2000 km → 视锥剔除 |

---

## 技术参考

### 相关文档
- `大世界浮点精度_CameraRelative技术方案.md` - 完整的数学推导和理论
- `调试指南_Camera_Relative_问题诊断.md` - 调试步骤和断点位置
- `大世界浮点数精度问题.pdf` - 原始问题描述

### 关键概念

#### 坐标系对比

| 类型 | 定义 | 示例 | 精度 |
|------|------|------|------|
| **世界坐标** | 相对于地图原点(0,0,0) | (-365472, 200, 432224) | ❌ float 精度损失 |
| **相对坐标** | 相对于当前世界原点 | (528, 200, 224) | ✅ 精度完美 |
| **世界原点** | 动态调整的参考点 | (-366000, 0, 432000) | - |

#### float 精度限制

```
float 结构：[符号位 1bit][指数 8bit][尾数 23bit]

大数值示例：
  -365472.0 (二进制需要 19 位整数部分)
  23 - 19 = 4 位小数精度
  → 只能精确到 2^-4 ≈ 0.0625
  → 0.5625 这样的小数会丢失！

小数值示例：
  528.0 (二进制需要 10 位整数部分)
  23 - 10 = 13 位小数精度
  → 可以精确到 2^-13 ≈ 0.00012
  → 精度提升 200+ 倍！
```

---

## 附录：Shader 代码

### Shader 是否需要修改？

**结论：不需要修改 Shader！**

**理由**：
如果 CPU 层正确工作（摄像机使用相对坐标），Shader 自动就是正确的：

```hlsl
// KarstBiomeTerrain_PS.txt
float3 V = normalize(U_PS_CameraPosition.xyz - i_WorldPos.xyz);

// 如果：
//   U_PS_CameraPosition = (528, 200, 224)  ← 相对坐标
//   i_WorldPos = (530, 200, 220)           ← 相对坐标（VS输出）
// 则：
//   V = normalize((528,200,224) - (530,200,220))
//     = normalize((-2,0,4))  ← 正确的方向向量！
```

**问题不在 Shader，在 CPU 层的坐标不一致！**

---

## 总结

### 已解决
✅ 理解 Camera-Relative 原理  
✅ 定位 GPU 层指针悬空问题  
✅ 确认 CPU 层 Rebasing 机制存在且工作  
✅ 发现摄像机被外部系统覆盖的问题  
✅ 理解 mPlayerWorldPosition 应保持世界坐标  
✅ 添加完整的诊断日志系统  

### 待解决
⏳ 找到外部系统覆盖摄像机的位置  
⏳ 选择并实现解决方案（A/B/C）  
⏳ 验证修复后地形和植被正常显示  
⏳ 重新启用 GPU Camera-Relative（长期目标）  

### 当前优先级
🔥 **P0**: 运行诊断，确认 WARNING 日志  
🔥 **P1**: 实现方案 A（Camera::setPosition 自动转换）  
📝 **P2**: 测试验证，收集新日志  
📝 **P3**: 优化性能，清理调试代码  

---

**最后更新**: 2025-10-24 15:10  
**下次更新**: 实现解决方案后更新本文档


