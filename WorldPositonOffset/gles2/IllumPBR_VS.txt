
#include <Common_Uniform_VS.inl>
#include <Common_Function.inl>

#ifdef USEINSTANCE
    #ifndef SKINNEDINSTANCE
        #undef HWSKINNED
    #endif
#endif

#ifdef USEINSTANCE
	#ifdef SKINNEDINSTANCE
       	uniform sampler2D S_2DExt0;
		uniform vec4 	U_VSCustom0[InstanceCount * UniformCount];
		uniform ivec4 	U_VSCustom1[(InstanceCount+3) >> 2];// animationData [cpu data type is uint32 , need recalculate index ]
	#else 
	    uniform vec4 	U_VSCustom0[InstanceCount * UniformCount];
	#endif
#else
	uniform vec4	U_WorldViewProjectMatrix[4];
	uniform vec4	U_WorldMatrix[3];
	uniform	vec4 	U_InvTransposeWorldMatrix[3];
	uniform vec4  U_ObjectMirrored;
#endif
uniform vec4 	U_VSGeneralRegister7; 	//x ---boundingbox min.y (current entity box) local box
										//y ---boundingbox max.y (current entity box)
										//z ---boundingbox min.y (parent entity box)
										//w ---boundingbox max.y (parent entity box)

#ifdef HWSKINNED
	#ifndef SKINNEDINSTANCE
		uniform vec4	U_BoneMatrix[3 * Bone_Matrix_Max_Cnt];
    #endif
#endif

in vec4 POSITION0;

#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		in vec2 TEXCOORD0;
		out vec4 	o_UV;
	#endif
#else
	in vec4 NORMAL0;
	in vec4 TEXCOORD0;
	in vec4 TANGENT0;
	
	#ifdef VERTEX_COLOR
		in vec4	COLOR0;
		out vec4 o_Diffuse;
	#endif

	out vec4 	o_UV;
	out vec4 	o_Fog;
	out vec3 	o_WNormal;
	out vec3 	o_Tangent;
	out vec3 	o_Binormal;
	out vec3 	o_EyeDir;
	out vec3	o_WPos;
	out vec3    o_PosInModel;
	out vec4    o_BoundBoxRange;

	#ifdef VERTEX_EXCITATION
		uniform vec4 U_VSGeneralRegister0;	//顶点扰动
	#endif
	
	#ifdef SoftNoColor
		uniform	vec4  U_InvWorldMatrix[3];
		uniform vec4  U_VSGeneralRegister1;	//偏移大小
		uniform	vec4  U_WorldScale;
	#endif
	#ifdef SOFTBOARD
		uniform vec4  U_VSGeneralRegister1;	//偏移大小
		uniform	vec4  U_WorldScale;
	#endif

	#ifdef USESHADOWMAP
	#include <Common_ShadowProjection_VS.inl>
		out vec4    	o_LightSpacePos[SHADOWSPLITE];
		out float		o_ViewSpaceZ;
	#endif
	#ifdef SOFTBOARD
	    out vec4    o_ClipPos;
    #endif
#endif

#ifdef PARABOLOID_MAPPING
	out float o_ClipDepth;
#endif

#ifdef HWSKINNED
	in vec4	BLENDWEIGHT0;
	in vec4	BLENDINDICES0;
#endif

#ifdef SKINNEDINSTANCE
	mat3x4 loadBoneMatrix (int animationData , int index)
	{
		mat3x4 rvt;
		rvt[0] = texelFetch(S_2DExt0,ivec2(index*3 + 0, animationData),0 );
		rvt[1] = texelFetch(S_2DExt0,ivec2(index*3 + 1, animationData),0 );
		rvt[2] = texelFetch(S_2DExt0,ivec2(index*3 + 2, animationData),0 );
		return rvt;
	}
#endif

void main()
{
	vec4  i_Pos =  vec4(POSITION0.xyz, 1.0f);
	float fHandedness = 1.0;
	#ifndef SHADOWPASS
		o_PosInModel = i_Pos.xyz;
	#endif
	vec4  o_PosInClip;
	vec4 Wpos;
	vec4 WorldMatrix[3];
	vec4 InvTransposeWorldMatrix[3];

	#ifdef HWSKINNED
		vec4	Weight		= BLENDWEIGHT0;
		ivec4   Index		= ivec4(BLENDINDICES0.xyzw);

		vec4 BoneMatC0	= vec4( 0.0 , 0.0 , 0.0 , 0.0 );
		vec4 BoneMatC1	= vec4( 0.0 , 0.0 , 0.0 , 0.0 );
		vec4 BoneMatC2	= vec4( 0.0 , 0.0 , 0.0 , 0.0 );

        #ifdef SKINNEDINSTANCE
			// recalculate index
			ivec4 animationData4 = U_VSCustom1[gl_InstanceID >> 2];
			int   animationData  = animationData4[gl_InstanceID & 3];
			for (int i = 0 ; i < 4 ; ++ i)
			{
				mat3x4 res=loadBoneMatrix(animationData,Index[i]);
				BoneMatC0 += Weight[i] * res[0];
				BoneMatC1 += Weight[i] * res[1];
				BoneMatC2 += Weight[i] * res[2];
			}
		#else
			for(int i=0;i<4;++i)
			{
				int idx = int(Index[i]);

				BoneMatC0	+=	U_BoneMatrix[idx*3+0]*Weight[i];
				BoneMatC1	+=	U_BoneMatrix[idx*3+1]*Weight[i];
				BoneMatC2	+=	U_BoneMatrix[idx*3+2]*Weight[i];
			}
		#endif
	#endif

#ifdef USEINSTANCE

  	#ifdef  HWSKINNED
		i_Pos = vec4(dot(BoneMatC0,i_Pos),dot(BoneMatC1,i_Pos),dot(BoneMatC2,i_Pos),1.0f);
	#endif
	#ifndef SHADOWPASS
		vec4 i_Normal =  vec4(NORMAL0.xyz, 0.0f);
		#ifdef  HWSKINNED
			i_Normal = vec4(dot(BoneMatC0,i_Normal),dot(BoneMatC1,i_Normal),dot(BoneMatC2,i_Normal),0.0f);
		#endif
		#ifdef VERTEX_EXCITATION
			i_Pos.xyz += i_Normal.xyz * U_VSGeneralRegister0.x * sin(TEXCOORD0.x * U_VSGeneralRegister0.y * U_VS_Time.x + TEXCOORD0.y * U_VSGeneralRegister0.z * U_VS_Time.x);
		#endif
	#endif

	int idxInst = gl_InstanceID * UniformCount;
	#ifdef HWSKINNED
		WorldMatrix[0] = U_VSCustom0[idxInst + 0];				// now is WroldViewMatrix
		WorldMatrix[1] = U_VSCustom0[idxInst + 1];
		WorldMatrix[2] = U_VSCustom0[idxInst + 2];
		InvTransposeWorldMatrix[0] = U_VSCustom0[idxInst + 3];
		InvTransposeWorldMatrix[1] = U_VSCustom0[idxInst + 4];
		InvTransposeWorldMatrix[2] = U_VSCustom0[idxInst + 5];

		vec4 vObjPosInCam;
		vObjPosInCam.x = dot(WorldMatrix[0], i_Pos);
		vObjPosInCam.y = dot(WorldMatrix[1], i_Pos);
		vObjPosInCam.z = dot(WorldMatrix[2], i_Pos);
		vObjPosInCam.w = 1.f;

		mat4 matWVP;
		matWVP[0] = U_ZeroViewProjectMatrix[0];
		matWVP[1] = U_ZeroViewProjectMatrix[1];
		matWVP[2] = U_ZeroViewProjectMatrix[2];
		matWVP[3] = U_ZeroViewProjectMatrix[3];
		o_PosInClip = vObjPosInCam * matWVP;

		WorldMatrix[0][3] += U_VS_CameraPosition[0];
		WorldMatrix[1][3] += U_VS_CameraPosition[1];
		WorldMatrix[2][3] += U_VS_CameraPosition[2]; 	// now is WroldMatrix

		Wpos.x = dot(WorldMatrix[0], i_Pos);
		Wpos.y = dot(WorldMatrix[1], i_Pos);
		Wpos.z = dot(WorldMatrix[2], i_Pos);
		Wpos.w = 1.0;
	#else 
		WorldMatrix[0] = U_VSCustom0[idxInst + 0];
		WorldMatrix[1] = U_VSCustom0[idxInst + 1];
		WorldMatrix[2] = U_VSCustom0[idxInst + 2];
		InvTransposeWorldMatrix[0] = U_VSCustom0[idxInst + 3];
		InvTransposeWorldMatrix[1] = U_VSCustom0[idxInst + 4];
		InvTransposeWorldMatrix[2] = U_VSCustom0[idxInst + 5];
		
		// WorldMatrix is now camera-relative (CPU did high-precision subtraction)
		// No need to subtract camera position again!
		vec4 vObjPosInCam;
		vObjPosInCam.x = dot(WorldMatrix[0], i_Pos);
		vObjPosInCam.y = dot(WorldMatrix[1], i_Pos);
		vObjPosInCam.z = dot(WorldMatrix[2], i_Pos);
		vObjPosInCam.w = 1.f;

		mat4 matWVP;
		matWVP[0] = U_ZeroViewProjectMatrix[0];
		matWVP[1] = U_ZeroViewProjectMatrix[1];
		matWVP[2] = U_ZeroViewProjectMatrix[2];
		matWVP[3] = U_ZeroViewProjectMatrix[3];
		o_PosInClip = vObjPosInCam * matWVP;

		// Reconstruct world position for lighting (add camera position back)
		Wpos.x = vObjPosInCam.x + U_VS_CameraPosition.x;
		Wpos.y = vObjPosInCam.y + U_VS_CameraPosition.y;
		Wpos.z = vObjPosInCam.z + U_VS_CameraPosition.z;
		Wpos.w = 1.0;
	#endif
	
	fHandedness = determinant(mat3(WorldMatrix[0].xyz,WorldMatrix[1].xyz, WorldMatrix[2].xyz));
	fHandedness = fHandedness >= 0.0 ? 1.0 : -1.0;
#else
  #ifdef  HWSKINNED
		i_Pos = vec4(dot(BoneMatC0,i_Pos),dot(BoneMatC1,i_Pos),dot(BoneMatC2,i_Pos),1.0f);
	#endif

	#ifndef SHADOWPASS
		vec4 i_Normal =  vec4(NORMAL0.xyz, 0.0f);
		#ifdef  HWSKINNED
			i_Normal = vec4(dot(BoneMatC0,i_Normal),dot(BoneMatC1,i_Normal),dot(BoneMatC2,i_Normal),0.0f);
		#endif
		#ifdef VERTEX_EXCITATION
			i_Pos.xyz += i_Normal.xyz * U_VSGeneralRegister0.x * sin(TEXCOORD0.x * U_VSGeneralRegister0.y * U_VS_Time.x + TEXCOORD0.y * U_VSGeneralRegister0.z * U_VS_Time.x);
		#endif
	#endif

	o_PosInClip.x = dot(U_WorldViewProjectMatrix[0], i_Pos);
	o_PosInClip.y = dot(U_WorldViewProjectMatrix[1], i_Pos);
	o_PosInClip.z = dot(U_WorldViewProjectMatrix[2], i_Pos);
	o_PosInClip.w = dot(U_WorldViewProjectMatrix[3], i_Pos);

	fHandedness = U_ObjectMirrored.w;
#endif

#ifdef PARABOLOID_MAPPING
	o_ClipDepth = o_PosInClip.z;
	ParaboloidMapping(o_PosInClip, U_ShadowLightDepthMulAdd.x, U_ShadowLightDepthMulAdd.z, U_ShadowLightDepthMulAdd.w);
#endif

#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		vec2 i_UV = TEXCOORD0.xy;
		o_UV.xy = i_UV;
	#endif
	#ifndef PARABOLOID_MAPPING
		o_PosInClip.z = ClampToNearPlane(o_PosInClip.z);
	#endif
#else
	vec4 i_UV		= TEXCOORD0;
	#ifdef SOFTBOARD
		o_ClipPos = o_PosInClip;
		o_UV.z = U_VSGeneralRegister1.x * U_WorldScale.x;
	#endif
	
	#ifndef USEINSTANCE
		WorldMatrix[0] =U_WorldMatrix[0];
		WorldMatrix[1] =U_WorldMatrix[1];
		WorldMatrix[2] =U_WorldMatrix[2];

		InvTransposeWorldMatrix[0] = U_InvTransposeWorldMatrix[0];
		InvTransposeWorldMatrix[1] = U_InvTransposeWorldMatrix[1];
		InvTransposeWorldMatrix[2] = U_InvTransposeWorldMatrix[2];

		Wpos.x = dot(WorldMatrix[0], i_Pos);
		Wpos.y = dot(WorldMatrix[1], i_Pos);
		Wpos.z = dot(WorldMatrix[2], i_Pos);
		Wpos.w = 1.0;
	#endif
	o_WPos = Wpos.xyz;
    vec4	vCamPos				=	U_VS_CameraPosition;
	#ifdef SoftNoColor
		vec3 camtoposi = normalize(o_WPos.xyz - vCamPos.xyz);
		vec3 viewDir = normalize(U_ViewDirection.xyz);
		float temp = dot(camtoposi, viewDir);
		temp = max(temp, 0.000001);
		o_WPos.xyz += camtoposi * U_VSGeneralRegister1.x * U_WorldScale.x/ temp;
		
		vec4 tempLocalPosi = vec4(o_WPos, 1.0);
		tempLocalPosi.x = dot(U_InvWorldMatrix[0], vec4(o_WPos, 1.0));
		tempLocalPosi.y = dot(U_InvWorldMatrix[1], vec4(o_WPos, 1.0));
		tempLocalPosi.z = dot(U_InvWorldMatrix[2], vec4(o_WPos, 1.0));
		
		o_PosInClip.x = dot(U_WorldViewProjectMatrix[0], tempLocalPosi);
		o_PosInClip.y = dot(U_WorldViewProjectMatrix[1], tempLocalPosi);
		o_PosInClip.z = dot(U_WorldViewProjectMatrix[2], tempLocalPosi);
		o_PosInClip.w = dot(U_WorldViewProjectMatrix[3], tempLocalPosi);
	#endif
	
	//vec4  i_Normal =  vec4(NORMAL0.xyz, 0.0f);
	vec4  i_Tangent = vec4(TANGENT0.xyz, 0.0f);

	#ifdef  HWSKINNED
		//i_Normal = vec4(dot(BoneMatC0,i_Normal),dot(BoneMatC1,i_Normal),dot(BoneMatC2,i_Normal),0.0f);
		i_Tangent = vec4(dot(BoneMatC0,i_Tangent),dot(BoneMatC1,i_Tangent),dot(BoneMatC2,i_Tangent),0.0f);
	#endif

	o_WNormal.x = dot(i_Normal.xyz, InvTransposeWorldMatrix[0].xyz);
	o_WNormal.y = dot(i_Normal.xyz, InvTransposeWorldMatrix[1].xyz);
	o_WNormal.z = dot(i_Normal.xyz, InvTransposeWorldMatrix[2].xyz);
	o_WNormal = normalize(o_WNormal);

	o_Tangent.x = dot(i_Tangent.xyz, WorldMatrix[0].xyz);
	o_Tangent.y = dot(i_Tangent.xyz, WorldMatrix[1].xyz);
	o_Tangent.z = dot(i_Tangent.xyz, WorldMatrix[2].xyz);
	o_Tangent = normalize(o_Tangent);

	o_Binormal.xyz = cross(o_Tangent.xyz, o_WNormal.xyz) * TANGENT0.w;
	o_Binormal.xyz *= fHandedness;

	o_UV.xy = i_UV.xy;

	vec3 camToWorld =  vCamPos.xyz - Wpos.xyz;

	o_EyeDir.xyz = camToWorld;

	vec3 camToWorldTemp = camToWorld;
	camToWorld.x = dot(U_VS_GravityRotationMatrix[0].xyz, camToWorldTemp);
	camToWorld.y = dot(U_VS_GravityRotationMatrix[1].xyz, camToWorldTemp);
	camToWorld.z = dot(U_VS_GravityRotationMatrix[2].xyz, camToWorldTemp);

	o_Fog = ComputeFogColor(camToWorld,U_FogParam.xy,U_FogParam.zw,U_FogRampParam,U_FogColorNear,U_FogColorFar);

	#ifdef USESHADOWMAP
		ProjectToLightSpace(o_LightSpacePos, o_WPos, o_WNormal);
		o_ViewSpaceZ = dot(U_MainCamViewMatrix, Wpos);
	#endif
	#ifdef VERTEX_COLOR
		o_Diffuse = COLOR0;
	#endif
#endif
#ifndef SHADOWPASS
	o_BoundBoxRange.x = U_VSGeneralRegister7.x;//dot(WorldMatrix[1], vec4(0.0f, U_VSGeneralRegister7.x, 0.0f, 1.0f));
	o_BoundBoxRange.y = U_VSGeneralRegister7.y;//dot(WorldMatrix[1], vec4(0.0f, U_VSGeneralRegister7.y, 0.0f, 1.0f));
	o_BoundBoxRange.z = U_VSGeneralRegister7.z;
	o_BoundBoxRange.w = U_VSGeneralRegister7.w;
#endif
	gl_Position = o_PosInClip;
}
