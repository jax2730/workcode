
#include <Common_Uniform_VS.inl>
#include <Common_Function.inl>

#ifdef USESHADOWMAP
float4 U_WorldMatrixBaseView[4];
#endif

#ifdef USEGPUCULL
#include <Common_GpuCull_CS.inl>
#endif

#ifdef USEGPUCULL
	#undef USEINSTANCE
	//#undef HWSKINNED
	//#undef SHADOWPASS
	//#undef VERTEX_EXCITATION
	//#undef SoftNoColor
	//#undef SOFTBOARD;
	//#undef ALPHA_TEST
	//#undef VERTEX_COLOR
	//#undef USESHADOWMAP
#endif

#ifdef USEINSTANCE
    #ifndef SKINNEDINSTANCE
      #undef HWSKINNED
	#endif
#endif

#ifdef USEINSTANCE
    #ifdef SKINNEDINSTANCE
 		uniform Texture2D S_2DExt0;
		SamplerState S_2DExt0SamplerState;
		float4 	U_VSCustom0[InstanceCount*UniformCount];
		uint4   U_VSCustom1[(InstanceCount + 3) >> 2]; // animationData [cpu data type is uint32 , need recalculate index ]
    #else
    	float4 	U_VSCustom0[InstanceCount * UniformCount];
	#endif
#else
	#ifndef USEGPUCULL
		float4	U_WorldViewProjectMatrix[4];	
		float4  U_WorldMatrix[3];
		float4  U_InvTransposeWorldMatrix[3];
		float4  U_ObjectMirrored;
	#endif
#endif

float4 	U_VSGeneralRegister7; 	//x ---boundingbox min.y (current entity box) local box
								//y ---boundingbox max.y (current entity box)
								//z ---boundingbox min.y (parent entity box)
								//w ---boundingbox max.y (parent entity box)


#ifdef HWSKINNED
	#ifndef SKINNEDINSTANCE
		float4	U_BoneMatrix[3 * Bone_Matrix_Max_Cnt];
	#endif
#endif

#ifdef MOTIONBLUR
	float4	U_LastWorldViewProjectMatrix[4];
	float4	U_LastBoneMatrix[3 * Bone_Matrix_Max_Cnt];
#endif

#ifdef USEGPUCULL
	StructuredBuffer<VertexDataCombine> B_CSCustom0;
	StructuredBuffer<InstanceData> B_CSCustom3;
	#ifdef CLUSTERDRAW
	//index
		ByteAddressBuffer B_CSCustom1;
	#endif
	struct VS_INPUT_GPUCULL
	{
		uint i_Pos0		: POSITION0;
		uint i_Pos1		: POSITION1;
	};
#endif

struct VS_INPUT
{
	float4 i_Pos		: POSITION0;
#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		float4 i_UV		: TEXCOORD0;	
	#endif
#else
	float4 i_Normal		: NORMAL0;
	float4 i_UV			: TEXCOORD0;	
	float4 i_Tangent	: TANGENT0;
#endif
	
	#ifdef VERTEX_COLOR
		float4	i_Diffuse	: COLOR0;
	#endif
	
#ifdef HWSKINNED
	float4	blend	: BLENDWEIGHT0;
	uint4	index	: BLENDINDICES0;
#endif
};

struct VS_OUTPUT
{
	float4	o_PosInClip			: SV_POSITION;
	#ifdef SHADOWPASS
		#ifdef ALPHA_TEST
			float4 o_UV		: TEXCOORD0;	
		#endif // ALPHA_TEST
	#else // SHADOWPASS
		float4 	o_UV				: TEXCOORD0;
		float4	o_Fog				: TEXCOORD1;
		float4	o_WNormal			: TEXCOORD2;
		float4	o_WPos				: TEXCOORD3;
		float4	o_Tangent			: TEXCOORD4;
		float4	o_Binormal			: TEXCOORD5;

		#ifdef VERTEX_COLOR
			float4 o_Diffuse		: TEXCOORD6;
		#endif // VERTEX_COLOR
		float   o_ViewSpaceZ					: TEXCOORD7;
		#ifdef USESHADOWMAP
			float4  O_LightSpacePos[SHADOWSPLITE]	: TEXCOORD8; 
		#endif // USESHADOWMAP
		float4	o_PosInModel		: TEXCOORD12;
		float4  o_BoundBoxRange		: TEXCOORD13;
		#ifdef MOTIONBLUR
			float4 o_VelUV		: TEXCOORD15;		
		#endif
		float4  O_RainLightSpacePos				: TEXCOORD16; 
		float4  o_vertexNormal 					: TEXCOORD17;
	#endif // SHADOWPASS

	//protecting point light shadow
	#ifdef PARABOLOID_MAPPING
		float	o_ClipDepth			: TEXCOORD14;
	#endif // PARABOLOID_MAPPING
};

#ifdef EDITOR_MODE
	#ifdef HierarchicalLOD
		uniform float4 U_VSGeneralRegister6;
		
	#endif
#endif

#ifdef SKINNEDINSTANCE
	float3x4 loadBoneMatrix (uint animationData , uint index)
	{
		float3x4 rvt ;

		rvt[0] = S_2DExt0.Load(uint3(index*3 + 0, animationData, 0));
		rvt[1] = S_2DExt0.Load(uint3(index*3 + 1, animationData, 0));
		rvt[2] = S_2DExt0.Load(uint3(index*3 + 2, animationData, 0));
		return rvt ;
	}
#endif

#ifdef USEGPUCULL

VS_OUTPUT main(VS_INPUT_GPUCULL IN_GPUCULL, uint i_InstanceID : SV_InstanceID, uint vertexId : SV_VertexID)
{
	uint idx = IN_GPUCULL.i_Pos0;
	#ifdef CLUSTERDRAW
		uint indexOffset = idx * INDEX_COUNT_PER_CLUSTER + vertexId;
		uint vertexOffset = idx * VERTEX_COUNT_PER_CLUSTER;
		idx = vertexOffset + B_CSCustom2[indexOffset];
	#endif
	VertexDataCombine vertex = B_CSCustom0[idx];
	
	InstanceData instData = B_CSCustom3[IN_GPUCULL.i_Pos1];
	
	VS_INPUT IN = (VS_INPUT)0;
	IN.i_Pos.xy = unpackHalf2x16(vertex.pos0);
	float2 tmpV = unpackHalf2x16(vertex.pos1);
	IN.i_Pos.z = tmpV.x;
	IN.i_Pos.w = 1.0;
	
	float4  U_WorldMatrix[3];
	U_WorldMatrix[0] = float4(instData.Transform[0], instData.Transform[1], instData.Transform[2], instData.Transform[3]);
	U_WorldMatrix[1] = float4(instData.Transform[4], instData.Transform[5], instData.Transform[6], instData.Transform[7]);
	U_WorldMatrix[2] = float4(instData.Transform[8], instData.Transform[9], instData.Transform[10], instData.Transform[11]);
	
	float4 U_InvTransposeWorldMatrix[3];
	U_InvTransposeWorldMatrix[0] = float4(instData.InvTransposeTransform[0], instData.InvTransposeTransform[1], instData.InvTransposeTransform[2], instData.InvTransposeTransform[3]);
	U_InvTransposeWorldMatrix[1] = float4(instData.InvTransposeTransform[4], instData.InvTransposeTransform[5], instData.InvTransposeTransform[6], instData.InvTransposeTransform[7]);
	U_InvTransposeWorldMatrix[2] = float4(instData.InvTransposeTransform[8], instData.InvTransposeTransform[9], instData.InvTransposeTransform[10], instData.InvTransposeTransform[11]);
	
	float4	U_WorldViewProjectMatrix[4];
	U_WorldViewProjectMatrix[0] = float4(dot(U_ViewProjectMatrix[0], float4(U_WorldMatrix[0].x, U_WorldMatrix[1].x, U_WorldMatrix[2].x, 0.0f)),
									dot(U_ViewProjectMatrix[0], float4(U_WorldMatrix[0].y, U_WorldMatrix[1].y, U_WorldMatrix[2].y, 0.0f)),
									dot(U_ViewProjectMatrix[0], float4(U_WorldMatrix[0].z, U_WorldMatrix[1].z, U_WorldMatrix[2].z, 0.0f)),
									dot(U_ViewProjectMatrix[0], float4(U_WorldMatrix[0].w, U_WorldMatrix[1].w, U_WorldMatrix[2].w, 1.0f))
	);
	U_WorldViewProjectMatrix[1] = float4(dot(U_ViewProjectMatrix[1], float4(U_WorldMatrix[0].x, U_WorldMatrix[1].x, U_WorldMatrix[2].x, 0.0f)),
									dot(U_ViewProjectMatrix[1], float4(U_WorldMatrix[0].y, U_WorldMatrix[1].y, U_WorldMatrix[2].y, 0.0f)),
									dot(U_ViewProjectMatrix[1], float4(U_WorldMatrix[0].z, U_WorldMatrix[1].z, U_WorldMatrix[2].z, 0.0f)),
									dot(U_ViewProjectMatrix[1], float4(U_WorldMatrix[0].w, U_WorldMatrix[1].w, U_WorldMatrix[2].w, 1.0f))
	);
	U_WorldViewProjectMatrix[2] = float4(dot(U_ViewProjectMatrix[2], float4(U_WorldMatrix[0].x, U_WorldMatrix[1].x, U_WorldMatrix[2].x, 0.0f)),
									dot(U_ViewProjectMatrix[2], float4(U_WorldMatrix[0].y, U_WorldMatrix[1].y, U_WorldMatrix[2].y, 0.0f)),
									dot(U_ViewProjectMatrix[2], float4(U_WorldMatrix[0].z, U_WorldMatrix[1].z, U_WorldMatrix[2].z, 0.0f)),
									dot(U_ViewProjectMatrix[2], float4(U_WorldMatrix[0].w, U_WorldMatrix[1].w, U_WorldMatrix[2].w, 1.0f))
	);
	U_WorldViewProjectMatrix[3] = float4(dot(U_ViewProjectMatrix[3], float4(U_WorldMatrix[0].x, U_WorldMatrix[1].x, U_WorldMatrix[2].x, 0.0f)),
									dot(U_ViewProjectMatrix[3], float4(U_WorldMatrix[0].y, U_WorldMatrix[1].y, U_WorldMatrix[2].y, 0.0f)),
									dot(U_ViewProjectMatrix[3], float4(U_WorldMatrix[0].z, U_WorldMatrix[1].z, U_WorldMatrix[2].z, 0.0f)),
									dot(U_ViewProjectMatrix[3], float4(U_WorldMatrix[0].w, U_WorldMatrix[1].w, U_WorldMatrix[2].w, 1.0f))
	);
	
	
	float4 U_ObjectMirrored = float4(0.0f, 0.0f, 0.0f, 1.0f);//float4(EOB(3, instID, ObjectMirrored)[0], EOB(3, instID, ObjectMirrored)[1], EOB(3, instID, ObjectMirrored)[2], EOB(3, instID, ObjectMirrored)[3]);
	
	uint flip = instData.Flip;
	flip = (flip & 0x55u) + ((flip & 0xAAu) >> 1u);
	flip = (flip & 0x33u) + ((flip & 0xCCu) >> 2u);
	if((flip & 1u) == 1u)
	{
		U_ObjectMirrored.w = -1.0f;
	}
	
	#ifndef SHADOWPASS
		IN.i_UV = float4(unpackHalf2x16(vertex.uv).xy, 0.0f, 0.0f);
		
		float2 Nxy = unpackHalf2x16(vertex.nt0).xy;
		float2 NzTx = unpackHalf2x16(vertex.nt1).xy;
		float2 Tyz = unpackHalf2x16(vertex.nt2).xy;
		
		IN.i_Normal = float4(Nxy.x, Nxy.y, NzTx.x, 0.0f);
		IN.i_Tangent = float4(NzTx.y, Tyz.x, Tyz.y, tmpV.y);
		
		#ifdef USEGPUCULL_TEXARRAY
			//o_TexRange.x = int(EOB(3, instID, Begin));
			//o_TexRange.y = int(EOB(3, instID, Lens));
		#endif
		
		
	#endif
	
#else
	
VS_OUTPUT main(VS_INPUT IN, uint i_InstanceID : SV_InstanceID)
{
	
#endif 

	VS_OUTPUT vsOut = (VS_OUTPUT)0;
	float4  pos =  float4(IN.i_Pos.xyz, 1.0f);
	float   fHandedness = 1.0f;

#ifdef USESHADOWMAP
	float4 wposView = float4(0.0f, 0.0f, 0.0f, 1.0f);
#endif
	float4 WorldMatrix[3];
	float4 InvTransposeWorldMatrix[3];
	#ifdef HWSKINNED
		float4	Weight		= IN.blend;
		uint4  Index		= IN.index;

		float4 BoneMatC0	= float4(0.0,0.0,0.0,0.0);		
		float4 BoneMatC1	= float4(0.0,0.0,0.0,0.0);
		float4 BoneMatC2	= float4(0.0,0.0,0.0,0.0);

        #ifdef SKINNEDINSTANCE
		   	// recalculate index
		   	uint 	animationData = U_VSCustom1[i_InstanceID >> 2][i_InstanceID & 3];
			for(int i=0;i<4;++i)
			{
		     	float3x4 res=loadBoneMatrix(animationData,Index[i]);
		     	BoneMatC0 += Weight[i] * res[0];
			 	BoneMatC1 += Weight[i] * res[1];
			 	BoneMatC2 += Weight[i] * res[2];
			}
	    #else
			for(int i=0;i<4;++i)
		    {
		    	int idx = Index[i];
		    	BoneMatC0	+=	U_BoneMatrix[idx*3+0]*Weight[i];	
		    	BoneMatC1	+=	U_BoneMatrix[idx*3+1]*Weight[i];	
		    	BoneMatC2	+=	U_BoneMatrix[idx*3+2]*Weight[i];	
		    }
		#endif
	#endif	
	
#ifdef USEINSTANCE

	#ifdef  HWSKINNED
		pos = float4(dot(BoneMatC0,pos),dot(BoneMatC1,pos),dot(BoneMatC2,pos),1.0f);		
	#endif
	#ifndef SHADOWPASS
		float4  normal =  float4(IN.i_Normal.xyz, 0.0f);
		#ifdef  HWSKINNED
			normal = float4(dot(BoneMatC0,normal),dot(BoneMatC1,normal),dot(BoneMatC2,normal),0.0f);
		#endif
	#endif
	
	int idxInst = i_InstanceID * UniformCount;
	#ifdef HWSKINNED
		WorldMatrix[0] = U_VSCustom0[idxInst + 0];		// now is WroldViewMatrix
		WorldMatrix[1] = U_VSCustom0[idxInst + 1];
		WorldMatrix[2] = U_VSCustom0[idxInst + 2];
		InvTransposeWorldMatrix[0] = U_VSCustom0[idxInst + 3];
		InvTransposeWorldMatrix[1] = U_VSCustom0[idxInst + 4];
		InvTransposeWorldMatrix[2] = U_VSCustom0[idxInst + 5];
		
		float4 vObjPosInCam ;
		vObjPosInCam.xyz  = mul((float3x4)WorldMatrix, pos);
		vObjPosInCam.w    = 1.f;
	#ifdef USESHADOWMAP
		wposView = vObjPosInCam;
	#endif
		vsOut.o_PosInClip = mul((float4x4)U_ZeroViewProjectMatrix, vObjPosInCam);

		WorldMatrix[0][3] += U_VS_CameraPosition[0];
		WorldMatrix[1][3] += U_VS_CameraPosition[1];
		WorldMatrix[2][3] += U_VS_CameraPosition[2]; 	// now is WroldMatrix

		float4 Wpos;
		Wpos.xyz 		  = mul((float3x4)WorldMatrix, pos);
		Wpos.w 			  = 1.0;
	#else
		WorldMatrix[0] = U_VSCustom0[idxInst + 0];
		WorldMatrix[1] = U_VSCustom0[idxInst + 1];
		WorldMatrix[2] = U_VSCustom0[idxInst + 2];
		InvTransposeWorldMatrix[0] = U_VSCustom0[idxInst + 3];
		InvTransposeWorldMatrix[1] = U_VSCustom0[idxInst + 4];
		InvTransposeWorldMatrix[2] = U_VSCustom0[idxInst + 5];
		
		float4 vObjPosInCam;

		vObjPosInCam.xyz = mul((float3x4)WorldMatrix, pos);
		vObjPosInCam.w = 1.0f;
	#ifdef USESHADOWMAP
		wposView = vObjPosInCam;
	#endif

		vsOut.o_PosInClip = mul((float4x4)U_ZeroViewProjectMatrix, vObjPosInCam);
		float4 Wpos = float4(vObjPosInCam.xyz + U_VS_CameraPosition.xyz, 1.0f);
	#endif
	fHandedness = determinant(float3x3(WorldMatrix[0].xyz, WorldMatrix[1].xyz, WorldMatrix[2].xyz));
	fHandedness = fHandedness >= 0.0 ? 1.0 : -1.0;
#else
	#ifdef  HWSKINNED
		pos = float4(dot(BoneMatC0,pos),dot(BoneMatC1,pos),dot(BoneMatC2,pos),1.0f);		
	#endif
	#ifndef SHADOWPASS
		float4  normal =  float4(IN.i_Normal.xyz, 0.0f);
		#ifdef  HWSKINNED
			normal = float4(dot(BoneMatC0,normal),dot(BoneMatC1,normal),dot(BoneMatC2,normal),0.0f);
		#endif
	#endif
	
	vsOut.o_PosInClip.x = dot(U_WorldViewProjectMatrix[0], pos);
	vsOut.o_PosInClip.y = dot(U_WorldViewProjectMatrix[1], pos);
	vsOut.o_PosInClip.z = dot(U_WorldViewProjectMatrix[2], pos);
	vsOut.o_PosInClip.w = dot(U_WorldViewProjectMatrix[3], pos);
	#ifdef USESHADOWMAP
	float4  vObjPosInView
    vObjPosInView.x = dot(U_WorldMatrixBaseView[0], pos);
	vObjPosInView.y = dot(U_WorldMatrixBaseView[1], pos);
	vObjPosInView.z = dot(U_WorldMatrixBaseView[2], pos);
	vObjPosInView.w = dot(U_WorldMatrixBaseView[3], pos);

	wposView = vObjPosInView;
	#endif
	
	#ifdef MOTIONBLUR
		float4  lastPos =  float4(IN.i_Pos.xyz, 1.0f);
		#ifdef HWSKINNED

			float4 lastBoneMatC0	= float4(0.0,0.0,0.0,0.0);		
			float4 lastBoneMatC1	= float4(0.0,0.0,0.0,0.0);
			float4 lastBoneMatC2	= float4(0.0,0.0,0.0,0.0);

			for(int i=0;i<4;++i)
			{
				int idx = Index[i];
				lastBoneMatC0	+=	U_LastBoneMatrix[idx*3+0]*Weight[i];	
				lastBoneMatC1	+=	U_LastBoneMatrix[idx*3+1]*Weight[i];	
				lastBoneMatC2	+=	U_LastBoneMatrix[idx*3+2]*Weight[i];	
			}
			lastPos = float4(dot(lastBoneMatC0,lastPos),dot(lastBoneMatC1,lastPos),dot(lastBoneMatC2,lastPos),1.0f);	
		#endif
	
		float4 lastPosInClip;
		lastPosInClip.x = dot(U_LastWorldViewProjectMatrix[0], lastPos);
		lastPosInClip.y = dot(U_LastWorldViewProjectMatrix[1], lastPos);
		lastPosInClip.z = dot(U_LastWorldViewProjectMatrix[2], lastPos);
		lastPosInClip.w = dot(U_LastWorldViewProjectMatrix[3], lastPos);
		
		float2 vel = vsOut.o_PosInClip.xy/vsOut.o_PosInClip.w-lastPosInClip.xy/lastPosInClip.w;
		vel *=float2(0.5f,-0.5f);
		vel = vel* U_VS_FPS.x*U_VS_FPS.y;
		vel =vel/ U_VS_ViewParam.zw * 0.5;
		vsOut.o_VelUV.xy = vel;
	#endif

	fHandedness = U_ObjectMirrored.w;	
#endif

#ifdef PARABOLOID_MAPPING
	vsOut.o_ClipDepth = vsOut.o_PosInClip.z;
	ParaboloidMapping(vsOut.o_PosInClip, U_ShadowLightDepthMulAdd.x, U_ShadowLightDepthMulAdd.z, U_ShadowLightDepthMulAdd.w);
#endif

#ifdef SHADOWPASS
	#ifdef ALPHA_TEST
		vsOut.o_UV = IN.i_UV;
	#endif
	
	#ifndef PARABOLOID_MAPPING
		//depthclamp
		vsOut.o_PosInClip.z = ClampToNearPlane(vsOut.o_PosInClip.z);
	#endif
	
#else

	#ifdef USEINSTANCE
		vsOut.o_WPos = Wpos;
	#else
		WorldMatrix[0] = U_WorldMatrix[0];
		WorldMatrix[1] = U_WorldMatrix[1];
		WorldMatrix[2] = U_WorldMatrix[2];

		InvTransposeWorldMatrix[0] = U_InvTransposeWorldMatrix[0];
		InvTransposeWorldMatrix[1] = U_InvTransposeWorldMatrix[1];
		InvTransposeWorldMatrix[2] = U_InvTransposeWorldMatrix[2];

		float4 vieMatrix[3];
		vieMatrix[0] = U_ViewMatrix[0];
		vieMatrix[1] = U_ViewMatrix[1];
		vieMatrix[2] = U_ViewMatrix[2];

		vsOut.o_WPos.xyz = mul((float3x4)WorldMatrix, pos);
		vsOut.o_WPos.w = 1.0;
		// vsOut.o_WPos.xyz = mul((float3x4)vieMatrix, vsOut.o_WPos);
	#endif
	float4	vCamPos				=	U_VS_CameraPosition;
	
	float4  tangent =  float4(IN.i_Tangent.xyz, 0.0f);
	
	#ifdef  HWSKINNED
		//normal = float4(dot(BoneMatC0,normal),dot(BoneMatC1,normal),dot(BoneMatC2,normal),0.0f);	
		tangent = float4(dot(BoneMatC0,tangent),dot(BoneMatC1,tangent),dot(BoneMatC2,tangent),0.0f);		
	#endif
	vsOut.o_vertexNormal = IN.i_Normal;
	
	vsOut.o_WNormal.xyz = mul((float3x4)InvTransposeWorldMatrix, float4(normal.xyz, 0.0f));
	vsOut.o_Tangent.xyz = mul((float3x4)WorldMatrix, float4(tangent.xyz, 0.0f));
	
	vsOut.o_Binormal.xyz = cross(vsOut.o_Tangent.xyz, vsOut.o_WNormal.xyz) * IN.i_Tangent.w;
	vsOut.o_Binormal.xyz *= fHandedness;
	
	
	vsOut.o_UV.xy = IN.i_UV.xy;
		
	
	float3 camToWorld =  vCamPos.xyz - vsOut.o_WPos.xyz;
	
	//vsOut.o_EyeDir.xyz = camToWorld;

	float4x4 gravityRotatePosMatrix;	
	gravityRotatePosMatrix[0] = U_VS_GravityRotationMatrix[0];
	gravityRotatePosMatrix[1] = U_VS_GravityRotationMatrix[1];
	gravityRotatePosMatrix[2] = U_VS_GravityRotationMatrix[2];
	gravityRotatePosMatrix[3] = U_VS_GravityRotationMatrix[3];
	camToWorld = mul(gravityRotatePosMatrix,float4(camToWorld.xyz,0.0f)).xyz;
		
	vsOut.o_Fog = ComputeFogColor(camToWorld, U_FogParam.xy, U_FogParam.zw, U_FogRampParam, U_FogColorNear, U_FogColorFar);
	float viewZ = -dot(U_MainCamViewMatrix, float4(vsOut.o_WPos.xyz, 1.0f));
	#ifdef USESHADOWMAP
		viewZ = -dot(U_ViewMatrix[2].xyz, wposView.xyz);
	    float4 vpos = wposView;
		float3 wNormal = normalize(vsOut.o_WNormal.xyz);
		float3 wLight = -U_VS_MainLightDirection.xyz;

		float shadowCos = dot(wNormal, wLight);
		float shadowSine = sqrt(1-shadowCos*shadowCos);
		
		float4 normalBias = ShadowNormalOffset * shadowSine * U_ShadowBiasMul;
		float4 vposOffset = vpos;
		const float BlendThreshold = 1;
	
		#if SHADOWSPLITE > 0
		{
		#if SHADOWSPLITE > 1
			float lerpAmt = smoothstep(1.0 - BlendThreshold, 1.0, viewZ / U_VS_ShadowSplit[0].x);
			vposOffset.xyz  = vpos.xyz + wNormal * lerp(normalBias[0], normalBias[1], lerpAmt);
		#else
			vposOffset.xyz  = vpos.xyz + wNormal * normalBias[0];
		#endif
		}
		vsOut.O_LightSpacePos[0].x = dot(U_LightVPMatrixView0[0], vposOffset);
		vsOut.O_LightSpacePos[0].y = dot(U_LightVPMatrixView0[1], vposOffset);
		vsOut.O_LightSpacePos[0].z = dot(U_LightVPMatrixView0[2], vposOffset);
		vsOut.O_LightSpacePos[0].w = dot(U_LightVPMatrixView0[3], vposOffset);
		#endif
		#if SHADOWSPLITE > 1	
		{
		#if SHADOWSPLITE > 2
			float lerpAmt = smoothstep(1.0 - BlendThreshold, 1.0, (viewZ - U_VS_ShadowSplit[0].x) / (U_VS_ShadowSplit[0].y - U_VS_ShadowSplit[0].x));
			vposOffset.xyz  = vpos.xyz + wNormal * lerp(normalBias[1], normalBias[2], lerpAmt);
		#else
			vposOffset.xyz  = vpos.xyz + wNormal * normalBias[1];
		#endif
		}
		vsOut.O_LightSpacePos[1].x = dot(U_LightVPMatrixView1[0], vposOffset);
		vsOut.O_LightSpacePos[1].y = dot(U_LightVPMatrixView1[1], vposOffset);
		vsOut.O_LightSpacePos[1].z = dot(U_LightVPMatrixView1[2], vposOffset);
		vsOut.O_LightSpacePos[1].w = dot(U_LightVPMatrixView1[3], vposOffset);
		#endif
		#if SHADOWSPLITE > 2	
	   	{
		#if SHADOWSPLITE > 3
			float lerpAmt = smoothstep(1.0 - BlendThreshold, 1.0, (viewZ - U_VS_ShadowSplit[0].y) / (U_VS_ShadowSplit[0].z - U_VS_ShadowSplit[0].y));
			vposOffset.xyz  = vpos.xyz + wNormal * lerp(normalBias[2], normalBias[3], lerpAmt);
		#else
			vposOffset.xyz  = vpos.xyz + wNormal * normalBias[2];
		#endif
		}
		vsOut.O_LightSpacePos[2].x = dot(U_LightVPMatrixView2[0], vposOffset);
		vsOut.O_LightSpacePos[2].y = dot(U_LightVPMatrixView2[1], vposOffset);
		vsOut.O_LightSpacePos[2].z = dot(U_LightVPMatrixView2[2], vposOffset);
		vsOut.O_LightSpacePos[2].w = dot(U_LightVPMatrixView2[3], vposOffset);
		#endif	
		#if SHADOWSPLITE > 3	
		vposOffset.xyz = vpos.xyz + wNormal * normalBias[3];
		vsOut.O_LightSpacePos[3].x = dot(U_LightVPMatrixView3[0], vposOffset);
		vsOut.O_LightSpacePos[3].y = dot(U_LightVPMatrixView3[1], vposOffset);
		vsOut.O_LightSpacePos[3].z = dot(U_LightVPMatrixView3[2], vposOffset);
		vsOut.O_LightSpacePos[3].w = dot(U_LightVPMatrixView3[3], vposOffset);
		#endif	
	#endif

	vsOut.O_RainLightSpacePos.x = dot(U_RainVPMatrix[0], vsOut.o_WPos);
	vsOut.O_RainLightSpacePos.y = dot(U_RainVPMatrix[1], vsOut.o_WPos);
	vsOut.O_RainLightSpacePos.z = dot(U_RainVPMatrix[2], vsOut.o_WPos);
	vsOut.O_RainLightSpacePos.w = dot(U_RainVPMatrix[3], vsOut.o_WPos);		
	vsOut.o_ViewSpaceZ = viewZ;
	
	#ifdef VERTEX_COLOR
		vsOut.o_Diffuse = IN.i_Diffuse;
	#endif

	#ifdef EDITOR_MODE
		#ifdef HierarchicalLOD
			vsOut.o_PosInClip = float4(2.0f * ((IN.i_UV.x - U_VSGeneralRegister6.x)* U_VSGeneralRegister6.z) - 1.0f, 1.0f - 2.0f * ((IN.i_UV.y - U_VSGeneralRegister6.y) * U_VSGeneralRegister6.w), 1.0f, 1.0f);
		#endif
	#endif

	vsOut.o_PosInModel = pos;

	vsOut.o_BoundBoxRange.x = U_VSGeneralRegister7.x;//dot(WorldMatrix[1], float4(0.0f, U_VSGeneralRegister7.x, 0.0f, 1.0f));
	vsOut.o_BoundBoxRange.y = U_VSGeneralRegister7.y;//dot(WorldMatrix[1], float4(0.0f, U_VSGeneralRegister7.y, 0.0f, 1.0f));
	vsOut.o_BoundBoxRange.z = U_VSGeneralRegister7.z;
	vsOut.o_BoundBoxRange.w = U_VSGeneralRegister7.w;
#endif


	return vsOut;
}
