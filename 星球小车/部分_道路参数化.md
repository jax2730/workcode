# 技术交底书 - 第一部分：道路与长度参数化

## 一、数据来源

### 1. PlanetRoadData的来源

`PlanetRoadData`是游戏场景中生成的道路数据结构（参见`EchoPlanetRoad.h`），包含以下信息：

```cpp
struct PlanetRoadData {
    uint16 roadID;                              // 道路唯一标识
    std::vector<BezierPoint> beziers;           // Bezier控制点序列
    struct Terminal {
        TerminalType type;  // City或Junction  
        uint16 id;
    } source, destination;                      // 道路起点和终点
};

struct BezierPoint {
    Vector3 point;                   // 控制点三维坐标（x, y, z）
    Vector3 source_control;          // 源控制向量（相对于point）
    Vector3 destination_control;     // 目标控制向量（相对于point）
    Vector3 normal;                  // 法向量（单位向量）
};
```

**数据生成方式**：
- 游戏场景编辑器中手动绘制道路曲线
- 或通过程序算法自动生成道路网络
- 每条道路由`n`个`BezierPoint`组成，形成`n-1`段三次Bezier曲线

### 2. 每段Bezier曲线的控制点定义

对于第`i`段曲线（连接第`i`和第`i+1`个BezierPoint）：

- **P₀** = `beziers[i].point`  
  起点位置（三维坐标）

- **P₁** = `beziers[i].point + beziers[i].destination_control`  
  起点控制点 = 起点 + 目标控制向量

- **P₂** = `beziers[i+1].point + beziers[i+1].source_control`  
  终点控制点 = 终点 + 源控制向量

- **P₃** = `beziers[i+1].point`  
  终点位置（三维坐标）

**示例**：假设beziers[0].point = (0,0,0), beziers[0].destination_control = (5,1,0), beziers[1].point = (20,0,0), beziers[1].source_control = (-5,1,0)，则第0段曲线的四个控制点为：

- P₀ = (0,0,0)
- P₁ = (5,1,0)  
- P₂ = (15,1,0)
- P₃ = (20,0,0)

## 二、Bezier曲线数学公式

### 1. 三次Bezier曲线参数方程

$$
\mathbf{B}(t) = (1-t)^3\mathbf{P}_0 + 3(1-t)^2 t\mathbf{P}_1 + 3(1-t)t^2\mathbf{P}_2 + t^3\mathbf{P}_3
$$

其中 $t \in [0,1]$ 是曲线参数。

**展开形式**：

$$
\mathbf{B}(t) = \mathbf{P}_0 + 3t(\mathbf{P}_1-\mathbf{P}_0) + 3t^2(\mathbf{P}_0-2\mathbf{P}_1+\mathbf{P}_2) + t^3(-\mathbf{P}_0+3\mathbf{P}_1-3\mathbf{P}_2+\mathbf{P}_3)
$$

**矩阵形式**：

$$
\mathbf{B}(t) = [1, t, t^2, t^3] \begin{bmatrix} 1 & 0 & 0 & 0 \\ -3 & 3 & 0 & 0 \\ 3 & -6 & 3 & 0 \\ -1 & 3 & -3 & 1 \end{bmatrix} \begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}
$$

**代码实现**（`EchoPiecewiseBezierUtil.cpp`第1133-1165行）：

```cpp
Vector3 PiecewiseBezierUtil::CInterpolate(const Vector3& from, const Vector3& from_des, 
                                          const Vector3& to, const Vector3& to_sou, float t) {
    // 构造4个控制点
    const Vector3& p0 = from;                    // 起点
    const Vector3 p1 = p0 + from_des;            // 起点+目标控制向量
    const Vector3 p2 = to + to_sou;              // 终点+源控制向量  
    const Vector3& p3 = to;                      // 终点
    
    // 计算t的幂次
    float t2 = t * t;
    float t3 = t2 * t;
    Vector4 tpowers(1, t, t2, t3);               // [1, t, t², t³]
    
    // Bernstein基函数系数矩阵
    static const DMatrix4 m4coeffs(
        1.0,  0.0,  0.0, 0.0,
       -3.0,  3.0,  0.0, 0.0,
        3.0, -6.0,  3.0, 0.0,
       -1.0,  3.0, -3.0, 1.0
    );
    
    // 控制点矩阵（每行一个控制点）
    DMatrix4 pt(
        p0.x, p0.y, p0.z, 0.f,
        p1.x, p1.y, p1.z, 0.f,
        p2.x, p2.y, p2.z, 0.f,
        p3.x, p3.y, p3.z, 0.f
    );
    
    // 矩阵乘法：[1,t,t²,t³] × M × [P₀,P₁,P₂,P₃]ᵀ
    Vector4 ret = tpowers * m4coeffs.transpose() * pt.transpose();
    return Vector3(ret.x, ret.y, ret.z);
}
```

### 2. 切线向量（一阶导数）

$$
\frac{d\mathbf{B}(t)}{dt} = 3(1-t)^2(\mathbf{P}_1-\mathbf{P}_0) + 6(1-t)t(\mathbf{P}_2-\mathbf{P}_1) + 3t^2(\mathbf{P}_3-\mathbf{P}_2)
$$

定义辅助向量：
- $\mathbf{W}_0 = 3(\mathbf{P}_1 - \mathbf{P}_0)$
- $\mathbf{W}_1 = 3(\mathbf{P}_2 - \mathbf{P}_1)$
- $\mathbf{W}_2 = 3(\mathbf{P}_3 - \mathbf{P}_2)$

则切线向量可表示为：

$$
\frac{d\mathbf{B}(t)}{dt} = [1, t, t^2] \begin{bmatrix} 1 & 0 & 0 \\ -2 & 2 & 0 \\ 1 & -2 & 1 \end{bmatrix} \begin{bmatrix} \mathbf{W}_0 \\ \mathbf{W}_1 \\ \mathbf{W}_2 \end{bmatrix}
$$

**代码实现**（`EchoPiecewiseBezierUtil.cpp`第1238-1266行）：

```cpp
Vector3 PiecewiseBezierUtil::CTangent(const Vector3& from, const Vector3& from_des, 
                                      const Vector3& to, const Vector3& to_sou, float t) {
    // 构造4个控制点
    const Vector3& p0 = from;
    const Vector3 p1 = p0 + from_des;
    const Vector3 p2 = to + to_sou;
    const Vector3& p3 = to;
    
    // 计算辅助向量W
    const Vector3 w0 = 3 * (p1 - p0);
    const Vector3 w1 = 3 * (p2 - p1);
    const Vector3 w2 = 3 * (p3 - p2);
    
    // 导数的Bernstein基函数系数矩阵
    static const Matrix3 m3coeffs(
        1.0,  0.0, 0.0,
       -2.0,  2.0, 0.0,
        1.0, -2.0, 1.0
    );
    
    Matrix3 pt(
        w0.x, w0.y, w0.z,
        w1.x, w1.y, w1.z,
        w2.x, w2.y, w2.z
    );
    
    Vector3 tpowers(1, t, t * t);                // [1, t, t²]
    
    // 矩阵乘法：[1,t,t²] × M × [W₀,W₁,W₂]ᵀ
    return tpowers * m3coeffs * pt;
}
```

## 三、道路弧长计算公式

### 1. 弧长积分公式

对于参数曲线 $\mathbf{B}(t)$，从 $t=0$ 到 $t=t_1$ 的弧长为：

$$
L(t_1) = \int_0^{t_1} \left\|\frac{d\mathbf{B}(t)}{dt}\right\| dt
$$

其中 $\left\|\frac{d\mathbf{B}(t)}{dt}\right\|$ 是切线向量的模长（速度大小）。

### 2. 高斯-勒让德数值积分

由于Bezier曲线的积分没有解析解，采用20点高斯-勒让德（Gauss-Legendre）积分法进行数值计算：

$$
L = \int_0^1 f(t) dt \approx \frac{1}{2} \sum_{k=1}^{20} C_k \cdot f\left(\frac{T_k+1}{2}\right)
$$

其中：
- $C_k$ 是第`k`个积分权重（代码第20-41行定义）
- $T_k$ 是第`k`个积分节点（代码第42-63行定义）  
- $f(t) = \left\|\frac{d\mathbf{B}(t)}{dt}\right\|$ 是被积函数

**20个积分节点和权重**：

高斯-勒让德积分法选取的20个节点和权重是经过数学优化的，可以用最少的采样点达到最高的积分精度。节点分布在[-1,1]区间，对称分布，靠近端点的节点密度较高。

**代码实现**（`EchoPiecewiseBezierUtil.cpp`第1060-1074行）：

```cpp
float PiecewiseBezierUtil::LengthFromTime(const Vector3& from, const Vector3& from_des, 
                                          const Vector3& to, const Vector3& to_sou, float time) {
    // time是积分上限，范围[0,1]
    float z = time / 2.f;              // 区间变换因子
    float length = 0;
    
    // 20点高斯积分求和
    for (int i = 0; i < 20; ++i) {
        // 将标准区间[-1,1]的节点T[i]变换到[0,time]
        float t = z * T[i] + z;        // t = (time/2) * (T[i] + 1)
        
        if (t >= 1.f) t = 1.f;         // 防止越界
        
        // 计算该点的切线模长
        float v = CTangent(from, from_des, to, to_sou, t).length();
        
        // 累加：权重 × 函数值
        length += C[i] * v;
    }
    
    // 乘以区间变换因子
    return z * length;
}
```

**参数说明**：
- `from`：起点坐标P₀
- `from_des`：起点目标控制向量（P₁-P₀）
- `to`：终点坐标P₃
- `to_sou`：终点源控制向量（P₂-P₃）
- `time`：积分上限，通常为1.0（计算整段曲线长度）

### 3. 道路总长度计算

对于包含`n`个控制点的道路（形成`n-1`段曲线）：

```cpp
// Road构造函数（Traffic.cpp第513-534行）
Road::Road(const PlanetRoadData& roadData) : mRoadsData(roadData) {
    mLens = 0.0f;                    // 道路总长度初始化为0
    mSeg.clear();                    // 清空累计长度数组
    
    // 遍历每一段曲线
    for (size_t i = 0; i < roadData.beziers.size() - 1; ++i) {
        const auto& startPoint = roadData.beziers[i];
        const auto& endPoint = roadData.beziers[i + 1];
        
        // 计算第i段曲线的长度（积分上限=1.0，即整段曲线）
        float currSeg = PiecewiseBezierUtil::LengthFromTime(
            startPoint.point,                  // P₀
            startPoint.destination_control,    // P₁-P₀
            endPoint.point,                    // P₃
            endPoint.source_control,           // P₂-P₃
            1.0f                               // 积分上限=1（整段曲线）
        );
        
        mLens += currSeg;              // 累加到总长度
        mSeg.push_back(mLens);         // 存储从起点到当前段终点的累计长度
    }
}
```

**数据结构**：
- `mLens`（float）：道路总长度（单位：米）
- `mSeg`（std::vector<float>）：累计长度数组
  - `mSeg[0]`：第0段的长度
  - `mSeg[1]`：第0段+第1段的累计长度
  - `mSeg[i]`：从起点到第i段终点的累计长度
  - `mSeg[n-2]`：道路总长度（等于mLens）

**示例**：假设一条道路有4个控制点（3段曲线），各段长度为10m、15m、12m，则：
- `mSeg = [10.0, 25.0, 37.0]`
- `mLens = 37.0`

## 四、弧长反求参数t的算法

### 1. 问题描述

给定车辆在某段曲线上的弧长位置`s`（单位：米），需要求解参数`t ∈ [0,1]`，使得：

$$
L(t) = \int_0^t \left\|\frac{d\mathbf{B}(\tau)}{d\tau}\right\| d\tau = s
$$

这是一个非线性方程求根问题，没有解析解，需要数值迭代求解。

### 2. Newton-Raphson迭代法

定义误差函数：

$$
F(t) = L(t) - s
$$

Newton-Raphson迭代公式：

$$
t_{k+1} = t_k - \frac{F(t_k)}{F'(t_k)} = t_k - \frac{L(t_k) - s}{\left\|\frac{d\mathbf{B}(t_k)}{dt}\right\|}
$$

其中：
- $F'(t) = \frac{dL(t)}{dt} = \left\|\frac{d\mathbf{B}(t)}{dt}\right\|$（根据Leibniz积分规则）

### 3. 二分法边界约束

为防止Newton法发散，结合二分法维护搜索区间`[tlower, tupper]`：

- 若 $F(t) > 0$（当前弧长大于目标值）：更新 `tupper = t`
- 若 $F(t) < 0$（当前弧长小于目标值）：更新 `tlower = t`
- 若Newton步越界，改用折半：`t = (tupper + tlower) / 2`

### 4. 完整算法

**代码实现**（`EchoPiecewiseBezierUtil.cpp`第1012-1047行）：

```cpp
float PiecewiseBezierUtil::LengthsTot(const Vector3& from, const Vector3& from_des, 
                                      const Vector3& to, const Vector3& to_sou, 
                                      float s, float t) {
    // 输入参数：
    //   from, from_des, to, to_sou: 定义一段Bezier曲线的4个控制点
    //   s: 目标弧长（单位：米）
    //   t: 初始参数估计（默认0，程序会自动设置）
    // 输出：参数t，使得L(t) = s
    
    // 计算该段曲线的总长度
    float BezierLens = PiecewiseBezierUtil::LengthFromTime(from, from_des, to, to_sou, 1.f);
    
    // 边界情况：如果目标弧长超过曲线总长度，返回t=1
    if (s >= BezierLens) return 1.f;
    
    // 初始估计：线性插值（假设弧长与参数成正比）
    t = (t == 0.f ? s / BezierLens : t);
    
    // 二分法边界
    float tlower = 0.f, tupper = 1.f;
    
    // Newton-Raphson迭代（最多10次）
    for (int i = 0; i < 10; ++i) {
        // 计算当前t对应的弧长
        float v = PiecewiseBezierUtil::LengthFromTime(from, from_des, to, to_sou, t);
        
        // 计算误差
        float F = v - s;
        
        // 收敛判断：误差小于1e-6米（0.001毫米）
        if (abs(F) <= 1e-6 || t >= 1.0f || t < 0.f) return t;
        
        // 计算导数F'(t) = ||dB/dt||
        float DFDT = PiecewiseBezierUtil::CTangent(from, from_des, to, to_sou, t).length();
        
        // Newton步
        float tC = t - F / DFDT;
        
        // 根据误差符号更新边界和参数
        if (F > 0) {  // 当前弧长 > 目标弧长，需要减小t
            tupper = t;
            if (tC <= tlower)  // Newton步越界，改用折半
                t = (tupper + tlower) / 2.f;
            else
                t = tC;
        }
        else {  // 当前弧长 < 目标弧长，需要增大t
            tlower = t;
            if (tC >= tupper)  // Newton步越界，改用折半
                t = (tupper + tlower) / 2.f;
            else
                t = tC;
        }
    }
    
    return t;
}
```

**算法流程图**：

```
输入：s（目标弧长），from, from_des, to, to_sou（曲线定义）
  ↓
计算曲线总长度 BezierLens = L(1.0)
  ↓
s >= BezierLens? ─Yes→ 返回 t = 1.0
  ↓ No
初始化：t = s / BezierLens （线性估计）
       tlower = 0.0, tupper = 1.0
  ↓
开始迭代（i=1 to 10）
  ├─ 计算当前弧长：v = L(t)
  ├─ 计算误差：F = v - s
  ├─ |F| < 1e-6? ─Yes→ 收敛，返回t
  ↓ No
  ├─ 计算导数：DFDT = ||dB/dt||
  ├─ Newton步：tC = t - F / DFDT
  ├─ 判断F符号并更新边界：
  │   F > 0? ─Yes→ tupper = t
  │          ─No→  tlower = t
  ├─ tC越界? ─Yes→ t = (tupper + tlower) / 2
  │          ─No→  t = tC
  └─ 继续下一次迭代
  ↓
返回 t
```

### 5. 参数t的含义和作用

- **定义**：`t`是Bezier曲线的标准参数，取值范围[0,1]
- **物理意义**：
  - `t=0`：曲线起点
  - `t=0.5`：曲线"中点"（参数意义，非几何中点）
  - `t=1`：曲线终点
- **用途**：
  - 通过`CInterpolate(..., t)`计算曲线上的三维坐标
  - 通过`CTangent(..., t)`计算该点的切线方向
  - **关键**：`t`与弧长`s`是非线性关系，高曲率处参数变化慢，低曲率处参数变化快

## 五、法向信息

### 1. 法向量的定义

`normal`是每个Bezier控制点附带的三维单位向量，表示道路表面的"上"方向。

**物理含义**：
- 垂直于道路表面
- 指向道路上方
- 与重力方向相反（对于水平道路）

### 2. 法向量的获取

**平面道路**：
```cpp
normal = Vector3::UNIT_Y = Vector3(0, 1, 0);  // 世界坐标系Y轴（向上）
```

**球面星球道路**：
```cpp
normal = (point - planetCenter).normalisedCopy();  // 径向外指向
```

**编辑器生成**：
- 根据相邻控制点的切线方向自动计算
- 保证道路不发生"扭曲"

### 3. 法向量的有效性判断

```cpp
// Traffic.cpp第685-688行
if (roadNormal.length() < 0.1f) {  // 模长过小视为无效
    roadNormal = Vector3::UNIT_Y;   // 回退到全局Y轴单位向量
}
roadNormal.Normalize();             // 归一化为单位向量
```

**无效情况**：
- 法向量模长接近0（长度<0.1）
- 法向量为零向量
- 法向量未正确初始化

**处理方式**：回退到全局坐标系的Y轴正方向(0,1,0)

---

## 总结

本部分介绍了基于Bezier曲线的道路参数化方法，包括：

1. **数据结构**：`PlanetRoadData`定义道路的控制点序列
2. **Bezier曲线**：三次Bezier曲线的数学公式和代码实现
3. **弧长计算**：20点高斯-勒让德数值积分
4. **参数反求**：Newton-Raphson迭代法结合二分法边界约束
5. **法向信息**：定义道路表面朝向的单位向量

**关键创新点**：
- 采用高精度数值积分计算弧长，确保任意曲率下的计算精度
- Newton法+二分法混合策略，保证参数反求的鲁棒性和收敛性
- 完善的边界条件处理和数值稳定性保障

这些基础为后续的车辆姿态计算、跟车控制和路径迁移提供了精确可靠的几何支撑。

